[{"title":"看板娘位置调整记录","url":"/posts/1a2004c6/","content":"问题起由\n在添加aplayer与看板娘之后，由于它们的默认位置都在左下角，因此需要将看板娘调整为右下角。\n问题解决\n打开\\themes\\butterfly\\source\\live2d-widget\\目录下的waifu.css文件找到\n#waifu &#123;\tbottom: -1000px;\tleft: 30px;\tline-height: 0;\tmargin-bottom: -10px;\tposition: fixed;\ttransform: translateY(3px);\ttransition: transform .3s ease-in-out, bottom 3s ease-in-out;\tz-index: 1;&#125;\n将left改为right距离可以根据自身需求进行调整。\n参考教程\n糖果屋教程贴https://akilar.top/posts/5b8f515f/","categories":["主题魔改（抄袭）记录"],"tags":["看板娘","Live2d","butterfly"]},{"title":"深度可分离卷积","url":"/posts/47786/","content":"最近写论文过程中用到了轻量级网络，其中深度可分离卷积可以大幅减少传统卷积的参数。本文记录深度可分离卷积的原理和参数计算。\nFLOPs与参数量\nFLOPs   用来衡量模型的时间复杂度，即计算机的算力。\n\n卷积层计算方式：(2×Cin×k2−1)×H×W×Cout=(Cin×k2−1+Cin×k2)×H×W×Cout(2\\times C_{in}\\times k^{2}- 1) \\times H\\times W\\times  C_{out}  = (C_{in}\\times k^{2}- 1+ C_{in}\\times k^{2})\\times H\\times W\\times  C_{out}(2×Cin​×k2−1)×H×W×Cout​=(Cin​×k2−1+Cin​×k2)×H×W×Cout​，CinC_{in}Cin​输入通道，CoutC_{out}Cout​输出通道，kkk为卷积大小，HHH和WWW分别为特征图的高和宽，当无偏置时，有−1-1−1，有偏置，无−1-1−1。\n全连接层计算方式：(2×Nin−1)×Nout(2\\times N_{in}-1)\\times N_{out}(2×Nin​−1)×Nout​，NinN_{in}Nin​为输入神经元数，NoutN_{out}Nout​为输出神经元数。\nLSTM层计算方式：(E+H)×H×4×2(E+H) \\times H \\times 4 \\times2(E+H)×H×4×2，EEE为词向量维度，即Input_sizeInput \\_ sizeInput_size，HHH为隐藏神经元个数，即Hidden_sizeHidden \\_ sizeHidden_size。\nGRU层计算方式：(E+H)×H×3×2(E+H) \\times H \\times 3 \\times2(E+H)×H×3×2。\n\n参数量  用来衡量模型的空间复杂度，即内存资源的消耗。\n\n卷积层计算方式：(Cin×k2+1)×Cout( C_{in}\\times k^{2}+ 1)\\times  C_{out}(Cin​×k2+1)×Cout​，当无偏置时，无+1+1+1，有偏置，有+1+1+1。\n全连接层计算方式：(Nin+1)×Nout( N_{in}+1)\\times N_{out}(Nin​+1)×Nout​。\nLSTM层计算方式：((E+H×H)+H)×4((E+H \\times H) +H)\\times 4((E+H×H)+H)×4。\nGRU层计算方式：((E+H×H)+H)×3((E+H \\times H) +H)\\times 3((E+H×H)+H)×3。\n\n常规卷积\n输入：(1,4,5,5)，卷积核：Conv2d(4,6,kernel=3,padding=1,stride=1,groups=1，bias=False)，输出：(1,6,5,5)，FLOPs：(2×4×3×3-1)×5×5×6=10650，参数量：(4×3×3+0)×6=216。\n\n分组卷积（Group Convolution）\n分组卷积,即ResNeXt,是受到Inception和AlexNet的启发。Inception 的论文中提到,对于卷积来说,卷积核可以看做一个三维的滤波器:通道维+空间维(Feature Map 的宽和高),常规的卷积操作其实就是实现通道相关性和空间相关性的联合映射。Inception 模块的背后存在这样的一种假设:卷积层通道间的相关性和空间相关性是可以退耦合的,将它们分开映射,能达到更好的效果.具体来说,经过不同卷积路径得到的特征图之间的耦合性较低,关注的主要特征不同,可以得到互为补充的特征图,以更完整的表示图像。\n输入：(1,4,5,5)，卷积核：Conv2d(4,6,kernel=3,padding=1,stride=1,groups=2，bias=False)，输出：(1,6,5,5)，FLOPs：(2×2×3×3-1)×5×5×1×3×2=5250，参数量：(2×3×3+0)×1×3×2=108。\n\n深度可分离卷积（Depthwise Separable Convolution）\n逐通道卷积（Depthwise Convolution）\n逐通道卷积的实质就是输出通道和分组等于输入通道的分组卷积。\n输入：(1,4,5,5)，卷积核：Conv2d(4,4,kernel=3,padding=1,stride=1,groups=4，bias=False)，输出：(1,4,5,5)，FLOPs：(2×1×3×3-1)×5×5×1×4=1700，参数量：(1×3×3+0)×1×4=36。\n\n逐点卷积（Pointwise Convolution）\n逐点卷积的实质就是卷积核大小为1的普通卷积。逐通道卷积完成后的通道数量与输入层的通道数相同，无法改变通道数。而且这种运算对输入层的每个通道独立进行卷积运算，没有有效的利用不同通道在相同空间位置上的特征信息。因此需要逐点卷积来将这些特征图进行组合生成新的特征图。\n输入：(1,4,5,5)，卷积核：Conv2d(4,6,kernel=1,padding=1,stride=1,groups=1，bias=False)，输出：(1,6,5,5)，FLOPs：(2×4×1×1-1)×5×5×1×6=1050，参数量：(4×1×1+0)×1×6=24。\n\n深度可分离卷积\nFLOPs：1700+1050=2750，参数量：36+24=60。\n参考文章\nCNN 模型所需的计算力（flops）和参数（parameters）数量是怎么计算的？ - 知乎 (zhihu.com)\n深度可分离卷积 - 知乎 (zhihu.com)\n深度可分离卷积(Depthwise Separable Convolution)和分组卷积(Group Convolution)的理解及PyTorch实现 - 知乎 (zhihu.com)\n","categories":["一些乱七八糟"],"tags":["分组卷积","深度可分离卷积"]},{"title":"Pytorch中LSTM输入输出的参数含义","url":"/posts/8ed/","content":"Pytorch LSTM源码\nclass RNNBase(Module):\t...    def __init__(self, mode, input_size, hidden_size,                 num_layers=1, bias=True, batch_first=False,                 dropout=0., bidirectional=False):\n初始化函数参数含义\n\ninput_size – 输入数据的大小，即词向量维度或者股票数据自变量的维度，如最低价、最高价等。\nhidden_size – 隐藏层的大小（即隐藏层节点数量）。\nnum_layers – LSTM层数量，默认等于1。\nbias – 偏置。\nbatch_first – 为True时，batch_size处于第一维度（h_n与c_n维度顺序不受影响），默认为False。\ndropout – 如果非0，就在除了最后一层的其它层都插入Dropout层，默认为0。\nbidirectional – 为True时是双向LSTM，即BiLSTM，默认为False。\n\n输入数据格式\ninput(seq_len, batch_size, input_size)\n\nseq_len/time_step –序列的长度 ，即句子的长度或单位数据的股票数据条数。\nbatch_size – 批次大小 ，即句子的条数或n个时间单位的股票数据。\ninput_size – 同初始化参数\n\nh_0(num_layers * num_directions, batch_size, hidden_size)\n\nnum_layers * num_directions， 即LSTM的层数乘以方向数量。这个方向数量是由前面介绍的bidirectional决定，如果为False,则等于1；反之等于2。\nbatch_size：同上。\nhidden_size: 隐藏层节点数。\n\nc_0(num_layers * num_directions, batch_s。ize, hidden_size)\n同h0。\n输出数据格式\noutput(seq_len, batch_size, num_directions * hidden_size)\n这个输出tensor包含了LSTM模型最后一层每个time step的输出特征。\nh_n(num_layers * num_directions, batch_size, hidden_size)\n只会输出最后个time step的隐状态结果。\nc_n ：(num_layers * num_directions, batch, hidden_size)\n只会输出最后个time step的cell状态结果。\n\n参考文章\n理解Pytorch中LSTM的输入输出参数含义 - 知乎 (zhihu.com)\nPytorch的LSTM的理解 - 知乎 (zhihu.com)\ndeep learning - What’s the difference between “hidden” and “output” in PyTorch LSTM? - Stack Overflow\n","categories":["一些乱七八糟"],"tags":["循环神经网络","LSTM"]},{"title":"Github Actions与EdgeOne自动化刷新","url":"/posts/56173d8a/","content":"写前哔哔\n老早就看到别人用Github Actions来实现Hexo自动化部署，但是看见一长串教程就退缩了，正好趁着休假抄一下店长的作业。\nHexo自动化部署 By Github Actions\n想当初挡住我的第一步就是上传仓库，各种git搞得我眼花缭乱，后来才知道Github官方还有个图形化应用程序Github Desktop可以极大简化操作：\n\n首先在本地电脑上新创建一个用于存放博客源码的文件夹（我的文件夹名是blog_source），然后将博客根目录（我的是blog）下的所有文件复制粘贴到blog_source中。\n打开 [Blogroot]/.gitignore,输入以下内容：\n\n.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/.deploy_git*/.ideathemes/butterfly/.git\n最好把butterfly目录下的.git文件夹删除，这是因为[Blogroot]/themes/butterfly 本身是一个独立的 Git 仓库（里面包含 .git 文件夹），所以 Git 会把它识别为 “嵌入式仓库”，而不是普通文件目录，直接 git add 无法正常跟踪其内容。\n\n在 [Blogroot] 新建 .github 文件夹,注意开头是有个 . 的。然后在 .github 内新建 workflows 文件夹，再在 workflows 文件夹内新建 autodeploy.yml,在 [Blogroot]/.github/workflows/autodeploy.yml 里面输入：\n\n# 当有改动推送到master分支时，启动Actionname: 自动部署on:  push:    branches:      - main #2020年10月后github新建仓库默认分支改为main，注意更改  release:    types:      - publishedjobs:  deploy:    runs-on: ubuntu-latest    steps:    - name: 检查分支      uses: actions/checkout@v2      with:        ref: main #2020年10月后github新建仓库默认分支改为main，注意更改    - name: 安装 Node      uses: actions/setup-node@v1      with:        node-version: &quot;24.x&quot; #action使用的node版本，建议大版本和本地保持一致。可以在本地用node -v查询版本号。    - name: 安装 Hexo      run: |        export TZ=&#x27;Asia/Shanghai&#x27;        npm install hexo-cli -g    - name: 缓存 Hexo      uses: actions/cache@v4      id: cache      with:        path: node_modules        key: $&#123;&#123;runner.OS&#125;&#125;-$&#123;&#123;hashFiles(&#x27;**/package-lock.json&#x27;)&#125;&#125;    - name: 安装依赖      if: steps.cache.outputs.cache-hit != &#x27;true&#x27;      run: |        npm install --save    - name: 生成静态文件      run: |        hexo clean        hexo generate    - name: 部署       run: |        cd ./public        git init        git config --global user.name &#x27;$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;&#x27;        git config --global user.email &#x27;$&#123;&#123; secrets.GITHUBEMAIL &#125;&#125;&#x27;        git add .        git commit -m &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; $(date +&quot;%Z %Y-%m-%d %A %H:%M:%S&quot;) Updated By Github Actions&quot;        git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;.github.io.git&quot; master:master        #git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/仓库名.git&quot; master:main\n需要注意的主要有三点：\n一是要保证uses: actions/cache@v4，因为GitHub Actions 工作流中使用了已被废弃的 actions/cache@v1 版本，GitHub 已不再支持该版本，需要更新到 v3 或 v4 版本。\n二是如果新仓库，那么分支应该都是main，但是最后一行的分支为master:main，而不是main:main。\n三是如果博客部署的仓库不是Github Pages所在的仓库的话，如仓库名.github.io，那么最后一行应该修改为git push --force --quiet &quot;https://$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;:secrets.GITHUBUSERNAME:$&#123;&#123; secrets.GITHUBTOKEN &#125;&#125;@github.com/$&#123;&#123; secrets.GITHUBUSERNAME &#125;&#125;/仓库名.git&quot; master:main\n\n参照以下视频利用Github Desktop上传博客源码至Github仓库：\n\n\n  \n  \n    \n  \n\n\n参照店长教程添加相关环境变量并查看部署情况：\n\n使用Github Action实现全自动部署https://akilar.top/posts/f752c86d/\n在Github Actions中添加EdgeOne自动化刷新\n在之前一篇教程中实现了在本地端用Hexo 的deployAfter钩子触发EdgeOne自动化刷新，但这种方法貌似在Actions中不起作用，于是大法启动。\n\n在scripts文件夹中新建edgeone-cache-actions.js，然后复制粘贴以下代码：\n\nconst tencentcloud = require(&quot;tencentcloud-sdk-nodejs-teo&quot;);const TeoClient = tencentcloud.teo.v20220901.Client;// 关键：判断脚本是否被直接执行（而非被Hexo自动加载）// 只有通过 `node scripts/edgeone-cache-actions.js` 执行时才会进入逻辑if (require.main === module) &#123;  main().catch(err =&gt; &#123;    console.error(&quot;执行失败:&quot;, err);    process.exit(1);  &#125;);&#125; else &#123;  // 被Hexo自动加载时，不执行任何逻辑（避免干扰）  console.log(&quot;[EdgeOne] 脚本被Hexo加载，跳过执行（仅手动执行生效）&quot;);&#125;async function main() &#123;  // 从环境变量读取配置  const edgeoneCfg = &#123;    enable: process.env.EDGEONE_ENABLE === &#x27;true&#x27;, // 严格判断字符串&#x27;true&#x27;    secretId: process.env.EDGEONE_SECRET_ID,    secretKey: process.env.EDGEONE_SECRET_KEY,    zoneId: process.env.EDGEONE_ZONE_ID,    region: process.env.EDGEONE_REGION || &#x27;ap-guangzhou&#x27;,    type: process.env.EDGEONE_TYPE || &#x27;purge_host&#x27;,    targets: process.env.EDGEONE_TARGETS ? process.env.EDGEONE_TARGETS.split(&#x27;,&#x27;) : [],    method: process.env.EDGEONE_METHOD || &#x27;invalidate&#x27;,    retry: process.env.EDGEONE_RETRY ? parseInt(process.env.EDGEONE_RETRY) : 2,  &#125;;  // 打印环境变量状态（调试用，可保留）  console.log(&quot;[EdgeOne] 环境变量检测:&quot;, &#123;    enable: edgeoneCfg.enable,    hasSecretId: !!edgeoneCfg.secretId, // 只显示是否存在，不打印具体值    hasZoneId: !!edgeoneCfg.zoneId  &#125;);  // 若未启用，直接退出  if (!edgeoneCfg.enable) &#123;    console.log(&quot;[EdgeOne] 缓存刷新已禁用（EDGEONE_ENABLE != &#x27;true&#x27;）&quot;);    process.exit(0);  &#125;  // 校验必填参数  const requiredFields = [&#x27;secretId&#x27;, &#x27;secretKey&#x27;, &#x27;zoneId&#x27;];  const missingFields = requiredFields.filter(field =&gt; !edgeoneCfg[field]);  if (missingFields.length &gt; 0) &#123;    console.error(`[EdgeOne] 配置错误：缺少必填参数 $&#123;missingFields.join(&#x27;, &#x27;)&#125;`);    process.exit(1);  &#125;  // 初始化客户端  const client = new TeoClient(&#123;    credential: &#123;      secretId: edgeoneCfg.secretId,      secretKey: edgeoneCfg.secretKey,    &#125;,    region: edgeoneCfg.region,    profile: &#123; httpProfile: &#123; endpoint: &quot;teo.tencentcloudapi.com&quot; &#125; &#125;,  &#125;);  // 带重试的缓存刷新  await refreshCacheWithRetry(client, edgeoneCfg, edgeoneCfg.retry);&#125;async function refreshCacheWithRetry(client, config, retryLeft) &#123;  try &#123;    const params = &#123;      ZoneId: config.zoneId,      Type: config.type,      Targets: config.targets,      Method: config.method,    &#125;;    const res = await client.CreatePurgeTask(params);    // 修正：根据实际API响应结构校验（EdgeOne返回JobId而非TaskId）    // 正确响应结构：&#123; RequestId: &quot;xxx&quot;, JobId: &quot;xxx&quot;, FailedList: [] &#125;    if (!res || !res.JobId) &#123;      throw new Error(`无效响应: 缺少JobId | $&#123;JSON.stringify(res)&#125;`);    &#125;    // 检查是否有失败的目标    if (res.FailedList &amp;&amp; res.FailedList.length &gt; 0) &#123;      throw new Error(`部分目标刷新失败: $&#123;JSON.stringify(res.FailedList)&#125;`);    &#125;    console.log(`✅ EdgeOne 刷新成功 | 任务 JobId：$&#123;res.JobId&#125;`);    console.log(`→ 类型：$&#123;params.Type&#125; | 方式：$&#123;params.Method&#125;`);    console.log(`→ 目标：$&#123;JSON.stringify(params.Targets)&#125;`);    return true;  &#125; catch (err) &#123;    if (retryLeft &gt; 0) &#123;      console.log(`⚠️ 刷新失败（剩余重试 $&#123;retryLeft&#125; 次）：$&#123;err.message&#125;`);      return refreshCacheWithRetry(client, config, retryLeft - 1);    &#125; else &#123;      console.error(`❌ 最终刷新失败：$&#123;err.message&#125;`);      process.exit(1);    &#125;  &#125;&#125;\n\n在autodeploy.yml中添加以下代码：\n\n- name: 刷新EdgeOne缓存  if: success()  # 只有部署成功才执行  env:    EDGEONE_ENABLE: &#x27;true&#x27;    EDGEONE_SECRET_ID: $&#123;&#123; secrets.EDGEONE_SECRET_ID &#125;&#125;    EDGEONE_SECRET_KEY: $&#123;&#123; secrets.EDGEONE_SECRET_KEY &#125;&#125;    EDGEONE_ZONE_ID: $&#123;&#123; secrets.EDGEONE_ZONE_ID &#125;&#125;    EDGEONE_REGION: &#x27;ap-guangzhou&#x27;  # 默认为广州地域    EDGEONE_TYPE: &#x27;purge_host&#x27;      # 刷新类型：域名级    EDGEONE_TARGETS: &#x27;www.sunboy.ltd,image.sunboy.ltd&#x27;  # 替换为你的实际域名    EDGEONE_METHOD: &#x27;invalidate&#x27;    # 清除方式：标记失效  run: |    node ./scripts/edgeone-cache-actions.js\n\n\n然后再在仓库的Settings &gt; Secrets and variables &gt; Actions中添加以下密钥：\n\n\nEDGEONE_SECRET_ID：腾讯云 API 密钥 ID\n\n\nEDGEONE_SECRET_KEY：腾讯云 API 密钥 Key\n\n\nEDGEONE_ZONE_ID：EdgeOne 的站点 ZoneID\n\n\n\n\n具体获取方法见：\nHexo博客实现腾讯云EdgeOne自动化刷新https://www.sunboy.ltd/posts/308ecd71/\n\n最后在Actions处查看deploy流程，如果显示以下内容说明EdegeOne缓存刷新成功：\n\n\n最后叨叨\n个人纯小白，全程豆包编码，仅做个人成功案例分享，大佬勿喷。\n","categories":["一些乱七八糟"],"tags":["hexo","腾讯云","EdgeOne","Github"]},{"title":"butterfly主页瀑布流双栏调整记录","url":"/posts/8af1eec/","content":"写前哔哔\n心血来潮，突然想把主页文章卡片改双栏瀑布流，根据官方文档教程，只需要把配置文件中的index_layout: 1改为index_layout: 6即可，但是在我27英寸显示器中成了三栏，更是当文章标题过长时会导致卡片错位情况，这种错位样式在三栏中个人觉得难以欣赏。\n问题解决\n通过请教我豆包大神，瀑布流布局（index_layout: 6 或 7）的列数是通过 .recent-post-item 的宽度计算控制的。默认配置在超宽屏幕（≥2000px）会显示 3 列。具体的样式在[BlogRoot]\\themes\\butterfly\\source\\css\\_page\\homepage.styl中调整，将3改为2即可：\nif $indexLayout == 6 || ($indexLayout == 7)  display: inline-block  width: calc(100% / 2 - 8px)  // 中等屏幕默认两列  vertical-align: top  +maxWidth768()  // 移动端单列    width: 100%  +minWidth2000()  // 超宽屏幕（≥2000px）默认三列-    width: calc(100% / 3 - 8px)+    width: calc(100% / 2 - 8px)    \n最终的效果：\n\n","categories":["主题魔改（抄袭）记录"],"tags":["butterfly","瀑布流","双栏"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start\nCreate a new post\n$ hexo new &quot;My New Post&quot;\nMore info: Writing\nRun server\n$ hexo server\nMore info: Server\nGenerate static files\n$ hexo generate\nMore info: Generating\nDeploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","categories":["主题魔改（抄袭）记录"],"tags":["hexo"]},{"title":"关于校园恋爱的思考","url":"/posts/3cebd8/","content":"前言\n最近也是好久没有刷番剧了，趁着国庆空闲，又找了一部纯爱番看看，剧名叫《薰香花朵凛然绽放》，是今年7月的新番，主要讲述了贵族女校桔梗的优等生和栗薰子和底层男校千鸟䌷凛太郎的恋爱故事，当然中间也不免引入了友情和亲情的经典套路，不过女主几乎每集都有新的造型，这点让我灰常喜爱啊，先放一张超长照片看看：\n图片来源：搁浅海鸟\n正文\n当然这不是本文的重点，我今天是想要对校园恋爱作一个不太深入的思考，主题是该不该在校园阶段进行恋爱，这里的校园阶段我限制为大学之前（毕竟大学都算是小大人了，完全可以为自己的所作所为进行负责），讨论的对象为普通家庭。目前，我也看了许多国内外的校园恋爱题材的电视剧、电影和番剧，绝大多数的结局应该都是欢天喜地的大圆满类型，可现实中修成正果的又有多少，尤其是像《薰香花朵凛然绽放》中男女主那样的两个极端，学霸与学渣的恋爱，在现实中走入婚姻殿堂的更是少之又少。因此，先亮明我的观点，我是不支持在校园阶段进行恋爱的，除非双方都是足够优秀和足够理性。下面我分享几个我身边的例子，当然有成功也有失败的结局。\n毁终生\n上来先放个大的，其实这个例子我现在回想起来也是相当炸裂的，我记不清男女双方是小学还是初中生，只记得无意间听到家人谈起，说有个亲戚家的孩子怀孕了。即使我那时还小，我也是对于这种消息感到十分震惊的，双方应该都是十几岁的年纪，怎么能承担起这种后果。结局也是毫不意外的，女方辍学再无消息，整个家庭自此也支离破碎。我不想对男女双方有过多的批判，而是强烈谴责他们的父母，倘若能对自己的孩子传授正确的恋爱观和性教育，又怎么会落个一地鸡毛的下场。\n辣眼睛\n高中时因为不适应县城学校的环境，没过多久我就借读回了家乡的高中，结果上待了没几天就看到了相当辣眼睛的场面。先说女方，是我们班名列前茅的学生，男方则是属于那种班级里的不良少年，也不知什么原因，两人成了男女朋友关系。在一个平常的课间，同学们有的在嬉戏打闹，有的在钻研习题，而男方忽然从最后一排来到了女方跟前，也不管女方是否同意，他就直接“啃”了上去，即使过程中女方再三拒绝，男方也还是自顾自地“啃”，自此之后，也是时常能看见这种辣眼睛场面。后来到了高考，女方的成绩相比平常并不是特别好，从而导致她没有考上自己心仪的学校，这中间与她的那段恋爱经历有没有关系不得而知，但是那辣眼睛的场面我想是令诸多同学感到十分不适的。好在后来女方复读了一年考上了一所985高校，至于结婚生子，我想肯定不是当初那个不良少年了吧。\n煎熬\n还是跟上面一个故事中的同一个班级里，有这么另外一对情侣，女方同样是成绩前茅的佼佼者，男方成绩中等靠下，有点痞气，但并不算是彻头彻尾的不良少年那种，两人跟我的关系都还算是不错。起初他们的感情非常好，这让我对校园恋爱也是充满了无限的憧憬，但好景不长，两人之间就开始出现了一些矛盾。起初只是简单的互相不搭理，一些小吵小闹，当然这些只是情侣之间的日常而已，但是再往后，女方的成绩开始了下滑，甚至开始有了自残行为。男方告诉我，之所以他们的恋爱这样煎熬，因为平常的一些小矛盾让女方无法专注于学习，但是她又不愿意对这段感情放手，所以两人只能越陷越深。高考后，女方只考上了一所普通的一本学校，男方倒是超常发挥，考上了心仪的学校，直到上大学一两年后，两人才宣布了分手，这段感情就此终结。\n青梅竹马\n这个故事就简单了许多，两个人都是我从幼儿园开始的同学，男方的家庭条件较为优渥，双方从小学开始就官宣了恋爱关系。当然那时我们都以为是小孩子玩游戏一样，估计着没几天两人就分道扬镳了，但没想到的是，两人直到大学仍然在一起，毕业后更是直接一起回到了家乡工作，去年和他们吃饭时还看到了他们的小宝宝，很是可爱。\n结论\n以上三个故事都是我的亲身经历，并没有涵盖所有的校园恋爱类型，但还是对我的恋爱观有一些启迪。在我看来，校园恋爱的底线是绝对不能偷吃禁果，否则就可能毁掉自己和对方的一生。当然，我还是坚持我最初提出的观点，将自己的这份感情放在心底就好。如果非要开始这段恋爱，请确认双方之间可以在学习和生活中起到相互促进的作用，并且不要影响到其他人的正常学习，不然的话终究是害人害己。\n结语\n这些故事掺杂了我对一些不良恋爱关系的一些吐槽，文字内容有些直球，希望大家多多包涵。\n","categories":["狂人日记"],"tags":["恋爱","校园"]},{"title":"回忆上学三两事（一）","url":"/posts/ff3d0d9c/","content":"过去的记忆太过久远，回想上学的这些年，有些事情却怎么也忘不掉。\n正文\n小曹老师\n幼儿园只学习拼音和算术两门课程，其中拼音可以算是我的强项，虽然作为一个甘肃人，分辨前后鼻音有点困难，但这并不妨碍我教别人装逼。在一次偶然的机会中，我被小学部的老师邀请去教高年级学生的拼音，那时的我真可谓是初生牛犊不怕虎，想都没想就直接答应了，要是现在的我估计早都跑没影了。在老师的带领下，我进入了目标教室。结果刚一进门，眼前的这些高我好几个头的“巨人”忽然一齐刷刷站起来，我以为是想他们要向老师问好，没想到他们出口就是“小曹老师好”。这下直接让我这小牛犊也脸红了好一阵子才缓过神来，为了对得起这声老师，我也是使出吃奶劲给我的学生进行传道授业解惑了。\n\n难忘的面条\n幼儿园期间，在某一天的下午放学时间，眼看着同学一个个被家长接走，我却左等右等，怎么也盼不到我的家里人。直到剩我一个人，我才意识到自己似乎被遗忘了，小珍珠瞬间就开始吧嗒吧嗒地往下掉了。我的语文老师看到我一个人之后，又陪着我等了一会，直到太阳快下山也没有结果后就将我带到了她的宿舍。我以为就是换个地方等，没想到她居然开始起锅烧油，没一会儿一碗热气腾腾的面就端了上来。吃完过后又将我直接送到了家中，在回去的路上我就在想，那应该是我吃过最好吃的面条了。\n\n地摊三结义\n谁上学期间还没有个狐朋狗友，我小学时就有两个，一个长得白皙，据说是从小喝羊奶长大的，另外一个跟我一样比较黝黑，具体是什么原因玩到一起已经记不太清了。在一个周末并且是有集市的一天，我们在玩了一天后快要回家时，“小白脸”突然提出一个建议：既然我们玩得这么好，为什么不跟《三国演义》中的刘关张一样，搞个三结义呢。我和另外一个黑小伙一听欣然同意，但是我们那没有桃园，于是就找了一个凉皮摊位，一人出了一块钱买了一碗凉皮，就当作为我们的结义仪式了。既然结义，肯定要分个大小，“小白脸”提议自己为老大，黑小伙是老二，我是老三（后来才知道“小白脸”年龄是最小的哈哈），我们两个都没意见，于是地摊三兄弟就此诞生了。\n\n（豆包太搞了，特么给哥们儿整成非洲人了，笑死我了）\n多年以后，因为我和“小白脸”都住在街道，所以现在仍有联系。而黑小伙因为分班缘故，再加之家离我们比较远，所以我们之间的联系也就渐渐没有了，去年才听说好像是已经结婚了，还是希望他生活一切顺利吧。\n车祸\n到了小学一般都不用家长接送了，都是同路的同学组成一列路队自己往回走，而和我同路路程最长的是一个姓张的小胖子，我回家的路上有一个大坡，他家在坡中间，我家在坡下。小学生天生就是顽皮的代名词，所以路队这种东西一般只有在学校跟前一段路程是非常整齐的，稍微走远一点之后就彻底乱了套了，我所在的路队也是如此。\n在一天的回家路上，在走出“禁区”之后，我们玩起了大风车的游戏，也就是边跑边狂甩衣服，有的同学甚至已经跑到了路中间，张姓的小胖子也在其中。正当我们玩得忘乎所以的时候，突然听到一声巨响，我转身一看一辆摩托车倒在了路上，一旁的驾驶员正在艰难起身，但视线再一转，发现竟还有一个跟我同龄的学生也躺在路上，身边还有一滩血迹。我赶忙确认同行的同学，发现少了一个人，而那个人竟然就是我们路队的张姓小胖子。摩托车司机起来后发现自己撞了人也是惊恐不已，连忙向路边过往的车辆进行求救，最后应该也是找到了一辆车，将张姓小胖子抱了进去就走了，而我似乎还看见他的头皮已经被撞的掀翻了起来一片血肉模糊。此时的我还有其他同学已经吓傻了，最后也不知道是怎么回家的。\n此后好长时间都没有看见过张姓小胖子，直到大概一两年之后，我才在放学回家路过在他家门口再次见到了他，只不过头上没了一半头发，看起来有些让人心毛，我打了声招呼就匆匆回家了。此后我能经常看到他在自家门口发呆，对于他之后的情况也无从得知了，只是当时血腥的车祸场面让我至今难以忘记。\n结语\n感觉想写的东西太多了，奈何自身小作文水平有限，每次只能憋一点，鸽时间太久心里又空落落的，所以还是多分几次发吧哈哈。\n未完待更。。。\n","categories":["回忆录"],"tags":["回忆","上学"]},{"title":"回忆找工作三两事","url":"/posts/a136637/","content":"开头问一句，有多少人现在的工作与自己的专业相关，至少我不是。从年少时，总有人问起，你将来想从事什么职业，可能大多数回答是科学家之类的，而在我记忆中似乎并没有对自己的职业规划立什么flag，总是走一步看一步，想来也有不少人也跟我是差不多的。毕业工作已经快一坤年了，回想自己的求职经历，至今还历历在目。\n本科求职经历——浅尝辄止\n2019年，正是考研热的高峰期，热衷于随波逐流的我自然不甘落后，也是跟随考研大军过起了朝7晚11的规律作息。当中最难熬的最属秋招阶段，这是对考研人的最大考验。看着周围的同学纷纷将发型梳成大人模样，向各家企业投去简历，我也是心热不已，那段时间毫无学习的念头。\n为了排除这种影响，我做出了一个大胆的决定：暂时放下考研，用一周的时间全身心投入找工作，一周之后，无论是否收到offer，都要回去继续准备考研。说干就干，立马向舍友要了简历模板，开始对自己的各种项目屎上雕花，将自己包装成一个高端人才（幻想）。然后就是一顿海投，几天后我就收到了一份国内某电器制造企业的回信，让我去某某酒店现场面试。\n说实话刚收到回信还是很激动的，但到了面试现场后，亲眼看到各路大神在面试官跟前滔滔不绝时我还是有些胆怯的，心想万一上去不知道说什么怎么办。但真到了我上场的时候，却并没有发生的我担心的事情，因为我对自己的专业知识还是很有自信的，那时我是不是也成为了别人眼里的大神呢哈哈。三轮面试后也是正式结束了我人生中第一次的面试，然后就是回去等待通知。\n意想不到的是，一天后，我就收到了该公司的offer，看着邮箱里的录用offer，又看着一旁的考研资料，我当时竟然产生了一次放弃考研的念头，想着直接出去挣money多好，可我已经准备这么久了，这么放弃是不是太可惜。经过一番挣扎，我还是放弃了这份诱人的offer,重新投入考研生活。\n研究生求职经历——世界的尽头\n研究生阶段的这段求职经历，让我真正见识到了现实的残酷和自己的无能。\n被耍猴了\n秋招前的暑假，正在我在家爽开游戏的时候，研究生同门群里突然跳出了一个消息：“offer收到了，大伙看看怎么样”。纳尼，我突然意识到又到了找工作的阶段，不过现在是不是也早了一些，但同门告诉我已经有好多人都已经开始行动了，这让我瞬间紧张起来，翻出本科的简历模板开始修修改改。\n2022年，新能源是一个看似很有前景的行业，尤其是某迪那段时间更是火的一塌糊涂，什么998、898、798之类的，听起来就很牛的样子，经过我查询后，某迪竟然还是一个学历厂，意思就是薪资待遇基本和个人实力没多大关系，只和你的学历挂钩。我一听这不正好适合我吗，一来我这低人好几等的双非也是没有什么跟人家讨价还价的资本，二来我的研究方向和当下的就业市场根本就不匹配。因此，就在别人海投的时候，我将心思一股脑全部投入到了某迪身上，通过各种渠道投递简历，内推、智联招聘、官方投递之类的。\n功夫不负有心人，我在某一天的午休时收到了某迪的面试电话，我激动地马上从床上蹦了起来。由于当时的疫情原因，都是采用线上面试的方式，而某迪的面试更为简单，只是通过电话问几个问题就完事了。技术面之后面试官就已经让我等待人事的通知了，根据我在网上看到的面经来说到这已经差不多就是等待录用了，因此我兴奋的更是好几天没睡好觉。\n几天后的一个下午，我收到了人事的电话，开口就是一句不好意思，听到这我的心已经凉了半截，只不过原因和我想的不一样。人事告诉我：“你的学校今年不在他们的考虑名单之内”，我还是不死心的问道：“那我还看到你们在我们学校不是还有专项招聘会吗，为什么会排除呢？”，“不是不招你们学校的，而是不招你们学校的研究生，只招本科生”。听到这我已经气笑了，默默挂断了电话，我读了三年研，到头来连本科生都不如。\n接连碰壁\n由于我前期都将功夫花到了某迪身上，而其他企业我都没投过简历，这也导致在秋招中期在别人接二连三收到offer的时候，我手里还是空无一物。那段时间，我疯狂地向各家公司，通过各个渠道投递简历，缺屡屡换来你已进入人才库的回信，看着周边那些平时连论文都发不出来的同学都收到了拒绝我的公司的offer，我当时心中是极度不平衡的，难道就是因为他们比我投递的早那么一段时间吗？\n双管齐下\n早早就听过一句话：世界的尽头是考公。为了不陷入毕业后家里蹲的尴尬局面，我开始了两头抓，一头主抓公考，另一头就是降低要求，先签一个公司保底。但是由于当时疫情反反复复，导致大多数时间我只能在宿舍进行学习，实际效果自然是大打折扣，最后的局面竟然是找保底公司成了主线。降低要求后找工作果然简单了许多，最终也是成功签约了宁夏某新能源光伏企业，因为看起来也是比较有前景的样子。\n黑暗\n签约后我又全身心投入了考公大业之中，此时心中也是轻松了许多，毕竟有保底在手，只是这个保底并不是特别满意而已，但是之后的一件事让我几乎放弃了考公这一条路。\n青春有几年，大学有几年，疫情几乎独占了我整个研究生生活。2022年年末，疫情进入了疯狂的传播阶段，而在学校的我们，似乎已经是待宰的羔羊。看着周围的同学一批批被送往放舱，自己也是每天过着胆战心惊的生活。某一天的半夜，正在整个宿舍熟睡的时候，一个舍友接到了学校疾控办的电话，我颤抖着打开了我的手机，豁然是出现了一串串未接，当时瞬间感觉自己陷入了无边的黑暗之中：这下轮到我了吗？经过反复做核酸并观察，我和我的舍友最终双双被送往了方舱医院。\n方舱的生活是无聊的，好在我们的环境相当不错，只是我的考公计划已经彻底泡汤了。既然不能继续考公大业，那只能继续B计划了，这次我将重点放在了国企、央企之中，三大运营商、中石油、中石化、烟草、医院科研岗等，都是我求职的对象。这期间也受到了中石油某一分公司的offer，但是我当时觉得这个分公司没有前景，就直接pass掉了。后来通过询问本地同学得知，这个分公司效益一直很不错，现在想起来，我也是常常后悔不已。\n出舱的时期正好是全国疫情都放开的时候，但是开学和公考时间都进行了延期，我回到家后进入到了漫长的空白期。那是的我什么都不想做，仿佛已经认命了一般，考公资料更是没翻过一页。转眼间就到了国考和省考的日子，我本来是放弃不想去的，后来在父亲的鼓励下还是硬着头皮上考场了。国考出成绩稍早一些，点开进面名单果然没有我，进面九人，而我排在了第十。在等待省考出成绩的过程中，母亲又不停的催促我去看看西安的另一家光伏企业，这家企业薪资待遇比上家搞出了一倍多，没有过多犹豫，给上家交了违约费，签订了西安这家公司。\n光明\n在和同门一起外出芭比Q的一天晚上，手机上跳出了省考出成绩的消息，同门纷纷调侃我是不是要准备烫西服了。我也是不对自己抱有任何希望，随手点开了成绩单。点开的一瞬间整个人是懵的，因为分数远超我的预期，甚至隐隐有岗一的感觉。由于正式的进面名单还是得半天到一天，那时已经没有了吃饭的心思，回宿舍拿着盯着手机出名单。还好当晚就出了名单，我的名字豁然在岗一的位置上，这让我几乎快跳了起来，只不过心里还是有些担忧，毕竟我的成绩与岗二岗三差距并不太大，很容易在面试中被反超。随后我就陷入了无限的纠结当中，究竟报不报班，因为一般来说，第一次参加面试都会选择报线下班，这样更加稳一点。而当时的我对我考公并没有很深的执念，一来我已经有了一份还不错的工作保底，二来我更向往大城市的生活，因此我最终选择了不报班，一切随缘。\n转眼间到了面试的时间，我一进候考室岗二就找到了我，相互聊了起来。了解得知，他也是辗转多个战场，这次已经是他第三次进入面试了，似乎这次面试势在必得，我也开玩笑说要是我面试第一的话我就放弃，让给你了，他自然是不信的，随后各自准备了起来。话说这面试可真是熬人，一直从早上八点到下午6点，期间没有手机。终于熬到了宣布成绩的时间，果不其然，岗二和岗三的面试成绩都比我高，不过并没有高多少，总成绩算下来我仍然是岗一，岗二总成绩也被岗三所超，真是造化弄人。\n抉择\n人生有多少个转折点，我想，这应该算一次。虽说我前边云淡风轻，可真到了选择的时候，我却没了主意，母亲建议我去西安公司看看之后再做决定。我听从了她的建议，第二天就买票去了西安，跟着HR转了一圈，整体还行，就是实验室的环境有些难以接受。回去的路上我顺便约了发小，也想听听他的建议。我们简单吃了一碗凉皮肉夹馍，而后一起坐在路边的花坛边交谈，他说：“我是必须要走出来并且要在外边立住脚跟的，因为我是我们家往出走的第一代”。是啊，他既是为了自己走出那一步，同时又背负了整个家庭的使命。那么我呢，哥哥已经在上海安了家，我已经不想要父母再为我操劳了。心中有了答案，我第二天就动身回学校了，同时拒绝了西安公司的offer。\n回家\n在经过体检、政审等环节的层层筛选过后，我正式收到了家乡gwy的入职通知。时至今日，要问我还后悔吗，还是有一些的，看到朋友圈的同学各种游玩有时也会羡慕不已，但在看到抱怨加班或着跳槽的消息时又会庆幸自己的选择。\n至少在目前，我会尽情享受这份不太完美的幸运。\n完结！\n","categories":["回忆录"],"tags":["回忆","工作"]},{"title":"文章页面默认头图透明调整记录","url":"/posts/4a9771df/","content":"写前哔哔\n由于我的博客是背景一图流，使用头图的话会很影响整体美观，官方文档的方法是在每篇文章Post Front-matter的处添加top_img: transparent配置选项来单独实现，但对我来说每次都要配置很是繁琐。\n正文开始\n\n方法一：根据店长关于背景一图流的教程中有提到过，可以在custom.css中添加如下代码解决：\n\n#page-header&#123;  background: transparent!important;&#125;\n它的作用是选择页面中 ID 为 page-header 的元素，将其背景设置为透明（transparent），并且通过 !important 声明强制提高该样式的优先级，确保它会覆盖其他可能存在的、针对该元素背景的样式规则。\n\n方法二：直接从源码入手，打开[Blogroot]\\themes\\butterfly\\layout\\includes\\header\\index.pug文件，将原来的 top_img = page.top_img || page.cover || theme.default_top_img 改为 top_img = page.top_img ? page.top_img : 'transparent'：\n\nif !theme.disable_top_img &amp;&amp; page.top_img !== false  case globalPageType    when &#x27;post&#x27;      - top_img = page.top_img ? page.top_img : &#x27;transparent&#x27;\n意思是：仅当明确设置 top_img 时，使用指定图片；不设置时，默认赋值为 'transparent'（透明标识）\n","categories":["主题魔改（抄袭）记录"],"tags":["butterfly"]},{"title":"尼康新手人像初拍","url":"/posts/df5b/","content":"准备\n自从买了相机之后，想拍人像的欲望愈发强烈，虽然我是个尼康佬，但并不妨碍我有一颗想拍人像的心。没模特？那就请老婆大人友情出演，没道具？那就树上随便摘两颗杏子充当。于是某一个周末的下午，造了两口饭之后我们就出发了。\n首先是拍摄地址的选择，由于我俩都是社恐人士，所以人多的地方是打死都不去的。经过一番踩点，最后选在了我们现场山上的一个亭子中，这个地方人少，还有草地、建筑可以作为拍摄背景，对我来说是一个灰常不错的选择。\n开拍\n虽然说拍摄之前我已经恶补了很多摄影知识，包括构图还有模特pose之类的，但真当到现场开拍之后我真的是完全不会了，感觉怎么拍都别扭，永远都是大头照。最后无奈只能打开小红书等软件现场搜索了一番教程，最后才勉强排出能看的照片。\n修图\n照片最后的效果如何，在我看来，至少在我这里，真的是三分靠拍摄，七分靠后期。之前也苦学了一阵子lr，但调下来还是各种不满意，最后还是加入了“快餐”式修图行列——像素蛋糕。我最喜欢的就是它的追色功能，导入一张样片之后就能一秒得到这个样片的预设，然后批量套入之后每张微调即可。后边我也试用了百度推出的同款竞品产品，但在这个功能上还是比像素蛋糕查了许多。\n成片\n最后也是献上成片（上传画质压缩较多，凑活看吧哈哈，大佬勿喷），所有照片均使用尼康Z502、唯卓仕AF 35 1.7拍摄，光圈优先模式：\n\n    [{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608657.avif\",\"alt\":\"20250830180608657.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608658.avif\",\"alt\":\"20250830180608658.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608659.avif\",\"alt\":\"20250830180608659.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608660.avif\",\"alt\":\"20250830180608660.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608661.avif\",\"alt\":\"20250830180608661.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608662.avif\",\"alt\":\"20250830180608662.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608663.avif\",\"alt\":\"20250830180608663.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608664.avif\",\"alt\":\"20250830180608664.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608665.avif\",\"alt\":\"20250830180608665.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608666.avif\",\"alt\":\"20250830180608666.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608667.avif\",\"alt\":\"20250830180608667.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608668.avif\",\"alt\":\"20250830180608668.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608669.avif\",\"alt\":\"20250830180608669.avif\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/北山/20250830180608670.avif\",\"alt\":\"20250830180608670.avif\",\"title\":\"\"}]\n  ","categories":["狂人日记"],"tags":["摄影","人像"]},{"title":"更换busuanzi统计服务记录","url":"/posts/7a06ae3d/","content":"写前哔哔\n今天打开博客总是在转圈圈，F12一看busuanzi已经504了，之前刷到文章就说busuanzi官方服务已经动不动就抽疯，没想到现在彻底用不了了，赶紧搜索朋友圈寻找平替。\n正文开始\n第一种方案就是自部署，但是需要服务器，我直接绕道。\n第二种就是使用别人部署好的服务，我找到的有以下几个：\n新版本不蒜子统计平台使用说明 - 杜老师说\nVercount - 网站流量计数器\n自建不蒜子 - 网站访问量统计\n我使用的是杜老师的服务，方法很简单：\n\n首先是在_config.butterfly.yml的CDN-&gt; option配置中添加如下内容：\n\nbusuanzi: https://jsd.onmicrosoft.cn/npm/penndu@17.0.0/bsz.js\n由于杜老师为了避免冲突，给原来的busuanzi id选择器加了 vaule 用于区别原版，因此还要进行如下操作\n\n打开[Blogroot]\\themes\\butterfly\\layout\\includes\\widget\\card_webinfo.pug文件，搜索busuanzi，将value_删除：\n\nelse if theme.busuanzi.site_uv  .webinfo-item    .item-name= `$&#123;_p(&#x27;aside.card_webinfo.site_uv_name&#x27;)&#125; :`    .item-count#busuanzi_site_uv      i.fa-solid.fa-spinner.fa-spinif theme.umami_analytics.enable &amp;&amp; theme.umami_analytics.UV_PV.site_pv  .webinfo-item    .item-name= `$&#123;_p(&#x27;aside.card_webinfo.site_pv_name&#x27;)&#125; :`    .item-count#umami-site-pv      i.fa-solid.fa-spinner.fa-spinelse if theme.busuanzi.site_pv  .webinfo-item    .item-name= `$&#123;_p(&#x27;aside.card_webinfo.site_pv_name&#x27;)&#125; :`    .item-count#busuanzi_site_pv      i.fa-solid.fa-spinner.fa-spinif theme.aside.card_webinfo.last_push_date  .webinfo-item    .item-name= `$&#123;_p(&#x27;aside.card_webinfo.last_push_date.name&#x27;)&#125; :`    .item-count#last-push-date(data-lastPushDate=date_xml(Date.now()))      i.fa-solid.fa-spinner.fa-spin\n\n打开[Blogroot]\\themes\\butterfly\\layout\\includes\\header\\post-info.pug进行同样的操作：\n\nmixin otherPV()  if theme.umami_analytics.enable &amp;&amp; theme.umami_analytics.UV_PV.page_pv    +pvBlock(&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;)      span#umamiPV(data-path=url_for(page.path))        i.fa-solid.fa-spinner.fa-spin  else if theme.busuanzi.page_pv    +pvBlock(&#x27;&#x27;, &#x27;post-meta-pv-cv&#x27;, &#x27;&#x27;)      span#busuanzi_page_pv        i.fa-solid.fa-spinner.fa-spin\n\nhexo三连后就可以看到侧边栏和文章页busuanzi服务正常运行了，就是访问数据得从头进行了。\n\n参考教程\n新版本不蒜子统计平台使用说明https://busuanzi.9420.ltd/\n","categories":["主题魔改（抄袭）记录"],"tags":["butterfly","busuanzi"]},{"title":"月全食人生首拍","url":"/posts/be73d8dd/","content":"写前哔哔\n最近一段时间我的Z502已经吃灰好久，一方面是由于天气原因，另一方面还是我这小县城着实没什么东西拍。然而在某一天的晚上刷着抖音时突然看到9月7日-9月8日晚有难得一遇的月全食，到时月亮将出现绝美的红色，那这种机会我自然不会放过，也是开始准备起来。\n时间表\n小红书@Li：2025年9月月全食拍摄攻略:错过再等3年！\n\n这次月全食是2025年最值得期待的天文事件之一，我国大部分地区可见全程！以下是关键时间点：\n半影食始9月7日23时27分，初亏9月8日0时27分，食既1时30分，食甚2时12分，生光2时53分，复圆3时57分，半影食终4时57分（均为北京时间），全食阶段持续1小时23分钟。\n月全食关键时间节点\n半影食阶段（肉眼不可见）：\n开始：9月7日23时27分。\n结束：9月8日4时57分。\n本影食阶段（肉眼可见）：\n初亏（月球开始进入地球本影）：0时27分。\n食既（全食开始）：1时30分。\n食甚（最大遮挡）：2时12分。\n生光（全食结束）：2时53分。\n复圆（月球完全离开本影）：3时57分。\n全食持续时间：1小时23分钟（1:30-2:53），月亮呈红铜色。\n\n\n开拍\n因为第二天还要上班，在加之我们这里当晚天气并不是特别好，所以我选择订了两点的闹钟，从食甚阶段开拍。时间到后，我下楼找到了月亮的大概方位，但是由于云层的遮挡，红月亮几乎肉眼不可见，无奈我只能打包回家。上楼之后还是不太甘心，发现自家阳台貌似是个不错的观景台，于是多等了一会。令我惊喜的是红月亮竟然真的露出来原本娇羞的模样，虽然还是有云层的影响，但完全到了可拍的状态。于是架上我的便携三脚架，一顿操作。\n成片\n在食甚阶段无脑拉高曝光即可，但由于个人经验实在是太少，竟忘了使用包围曝光的方法来控制生光阶段的拍摄，从而导致后期操作空间不是太多。最后奉上成片：\n\n    [{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210346420.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210346420.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210535861.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210535857.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/月全食/DSC_1688-已增强-降噪.jpg\",\"alt\":\"DSC_1688-已增强-降噪.jpg\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210535859.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/%E6%9C%88%E5%85%A8%E9%A3%9F/20250908210535858.avif\",\"alt\":\"\",\"title\":\"\"}]\n  \n食甚阶段个人拍摄参数：光圈 f/6.3，ISO 1000，快门1/2秒\n","categories":["狂人日记"],"tags":["摄影","月全食","月亮","星空"]},{"title":"清羽飞扬分类条添加记录","url":"/posts/ec89d020/","content":"写前哔哔\n近期重建博客，想用一种简洁的分类条，最终也是选择了清羽飞扬的样式，但是在复现抄袭的过程中遇到了最终的样式和演示效果不一致的问题，如图所示。\n\n问题解决\n通过请教清羽飞扬本人，原来是我用的最新butterfly版本和旧版本文件不一致有关，解决办法就是在跳过原教程中的category.pug和index.pug添加代码步骤，然后打开[BlogRoot]\\themes\\butterfly\\layout\\includes\\mixins\\indexPostUI.pug文件，添加以下两行代码，删除+号\nmixin indexPostUI()  - const indexLayout = theme.index_layout  - const masonryLayoutClass = (indexLayout === 6 || indexLayout === 7) ? &#x27;masonry&#x27; : &#x27;&#x27;  #recent-posts.recent-posts.nc(class=masonryLayoutClass)+    #category-bar.category-bar+      include ../categoryBar.pug    .recent-post-items      each article, index in page.posts.data\n具体的样式在[BlogRoot]\\themes\\butterfly\\source\\css\\_layout\\category-bar.styl中调整：\n#category-bar  padding 7px 11px  background var(--card-bg)  border-radius 8px  display flex  white-space nowrap  overflow hidden  transition 0.3s  height 50px  width 100%  justify-content space-between  user-select none  align-items center  margin-bottom 20px  font-size 17px  font-family &quot;shou&quot;  font-weight 500  .category-bar-right    display flex    border-radius 8px    align-items center    .category-bar-more      margin-left 4px      margin-right 4px      border-radius 8px      padding 0 8px      color var(--text-highlight-color)      &amp;:hover        background var(--btn-hover-color)        color #FFFFFF      &amp;.select        a          background var(--btn-bg)          color var(--btn-color)          &amp;:hover            background var(--btn-hover-color)            color #FFFFFF  .category-bar-items    width 100%    white-space nowrap    overflow-x scroll    scrollbar-width: none    -ms-overflow-style: none    overflow-y hidden    display flex    border-radius 8px    align-items center    height 30px    &amp;::-webkit-scrollbar      display: none    .category-bar-item      a        padding .1rem .5rem        margin-right 6px        border-radius 8px        display flex        align-items center        height 30px        color var(--text-highlight-color)        &amp;:hover          background var(--btn-hover-color)          color #FFFFFF      &amp;.select        a          background var(--btn-bg)          font-weight 550          color var(--btn-color)          &amp;:hover            background var(--btn-hover-color)            color #FFFFFF\n最终的效果：\n\n\n参考教程\n魔改笔记七：分类条及外链卡片https://blog.liushen.fun/posts/a64defb4/","categories":["主题魔改（抄袭）记录"],"tags":["butterfly","分类条"]},{"title":"源站域名和回源HOST头理解及个人实践","url":"/posts/1930c336/","content":"写前哔哔\n最近在配置时CDN时总会遇到源站域名和回源 Host 头，尤其是当回源 Host 头设置为源站域名时更是傻傻分不清，今天一定要狠狠地搜索一波，以下内容部分来自豆包。\n源站域名和回源 Host 头的区别\n一、核心定义与作用区别\n1. 源站域名（CDN 的 “目标服务器地址”）\n\n定义：CDN 节点要 “物理连接” 的服务器域名（或 IP），即实际存储你的网页资源的服务器地址（例如你的 EO Pages 源站域名 yourdomain.pages.eo.tencentcloud.com）。\n作用：解决 “CDN 节点该连接哪台服务器” 的问题。\n类比：相当于你寄快递时的 “收件人地址”（比如 “XX 市 XX 路 XX 号”），确保快递能送到正确的建筑物。\n\n2. 回源 Host 头（CDN 的 “访问目标标识”）\n\n定义：CDN 节点连接到源站服务器后，在 HTTP/HTTPS 请求中携带的 Host 字段（例如 yourdomain.pages.eo.tencentcloud.com）。\n作用：解决 “连接到服务器后，要访问这台服务器上的哪个具体站点” 的问题。\n类比：相当于你到了 “XX 市 XX 路 XX 号” 这个建筑物后，告诉门卫 “我要找 301 室的住户”，确保能找到具体的人。\n\n二、为什么必须同时配置？\n源站服务器（尤其是 EO Pages 这类云服务的源站）通常是 “多站点共享一台 / 一组服务器” 的模式 —— 即一台服务器上可能同时托管成百上千个用户的站点。此时：\n\n仅配置源站域名：CDN 节点能正确连接到源站服务器（相当于快递到了建筑物），但服务器不知道你要访问它上面的哪个站点（不知道找 301 室还是 502 室），可能返回错误或默认页面。\n仅配置回源 Host 头：CDN 节点不知道该连接哪台服务器（快递不知道往哪个地址送），更无法发起请求。\n\n三、特殊场景：两者可能相同，但逻辑不同\n在很多情况下，源站域名和回源 Host 头会填写相同的域名（例如都填 yourdomain.pages.eo.tencentcloud.com），但这只是 “值相同”，而非 “作用相同”：\n\n源站域名是 “网络层” 的连接目标（告诉 CDN 节点 “连哪里”）。\n回源 Host 头是 “应用层” 的访问标识（告诉服务器 “取什么”）。\n\n甚至在某些场景下，两者必须不同：\n例如，若源站用 IP 地址（如 1.2.3.4）作为源站域名，此时回源 Host 头必须填写你的 EO Pages 源站域名（yourdomain.pages.eo.tencentcloud.com）—— 因为服务器需要通过 Host 头识别站点，而 IP 地址无法直接关联到具体站点。\n总结\n\n源站域名：解决 “CDN 节点连接哪台服务器” 的问题（网络层）。\n回源 Host 头：解决 “连接后访问服务器上哪个站点” 的问题（应用层）。\n\n回源 Host 使用加速域名和源站域名的区别\n一、核心定义与请求链路差异\n1. 回源 Host 使用加速域名\n\n定义：加速域名是 CDN 分配给用户的访问入口（如 cdn.example.com），用户直接通过该域名访问资源。若回源 HOST 填写加速域名，CDN 节点会在回源请求中携带 Host: cdn.example.com。\n请求链路：\n\n用户访问：用户通过 cdn.example.com 发起请求。\nCDN 节点处理：若节点未缓存资源，CDN 节点向源站请求资源，此时请求头的 Host 字段为 cdn.example.com。\n源站响应：\n\n若源站未配置加速域名：源站无法识别 cdn.example.com，可能返回 404 错误或默认站点内容。\n若源站配置了加速域名：源站正常返回资源，但此时加速域名需同时在源站和 CDN 中配置，可能导致解析闭环（例如加速域名通过 CNAME 指向 CDN 节点，而 CDN 节点又回源到该域名，形成无限循环）。\n\n\n\n\n\n2. 回源 Host 使用源站域名\n\n定义：源站域名是实际存储资源的服务器域名（如 origin.example.com），由云服务提供商（如 EO Pages）分配。若回源 HOST 填写源站域名，CDN 节点会携带 Host: origin.example.com。\n请求链路：\n\n用户访问：用户通过 cdn.example.com 发起请求。\nCDN 节点处理：未命中缓存时，CDN 节点向源站域名 origin.example.com 发起请求，携带 Host: origin.example.com。\n源站响应：源站根据 Host 头直接匹配到对应的站点资源，正常返回内容。\n\n\n\n二、关键区别与风险对比\n\n\n\n维度\n回源 HOST 使用加速域名\n回源 HOST 使用源站域名\n\n\n\n\n源站识别逻辑\n源站需配置加速域名才能正确响应，否则可能返回 404 或默认内容。\n源站默认配置源站域名，直接匹配站点资源，无需额外配置。\n\n\n解析闭环风险\n加速域名通常通过 CNAME 指向 CDN 节点，若回源 HOST 使用加速域名，CDN 节点可能再次解析到自身，形成无限循环。\n源站域名直接指向真实服务器 IP，避免 CDN 内部解析闭环。\n\n\n适用场景\n仅在源站明确配置了加速域名（如自建源站同时托管加速域名和源站域名）时可用。\n适用于绝大多数场景，尤其是云服务提供商（如 EO Pages）的源站默认仅配置源站域名的情况。\n\n\nCDN 性能影响\n若源站未配置加速域名，CDN 节点可能需要多次重定向或返回错误，增加响应延迟。\n直接命中源站配置，响应效率更高。\n\n\n配置复杂度\n需同时在 CDN 和源站配置加速域名，且需确保 DNS 解析链不冲突。\n只需在 CDN 配置源站域名，无需额外操作。\n\n\n\n总结\n回源 HOST 使用加速域名和源站域名的本质区别在于：前者依赖源站对加速域名的额外配置，且存在解析闭环风险；后者直接匹配源站默认配置，是云服务场景下的最佳实践。\nEO CDN个人配置实践\n搭配方案：\n\n\n\n情况编号\n加速域名\n源站域名（CDN 配置的源站地址）\n回源 HOST 头使用的值\n自定义域名（EO Pages 绑定的域名）\n访问结果\n\n\n\n\n情况 1\nwww.sunboy.ltd\nblogggg-e3d9muwx.edgeone.run（EO 默认生成）\n加速域名 www.sunboy.ltd\n有（www.sunboy.ltd）\n正常访问\n\n\n情况 2\nwww.sunboy.ltd\nblogggg-e3d9muwx.edgeone.run（EO 默认生成）\n加速域名 www.sunboy.ltd\n无\n正常访问\n\n\n情况 3\nwww.sunboy.ltd\nblogggg-e3d9muwx.edgeone.run（EO 默认生成）\n源站域名 blogggg-e3d9muwx.edgeone.run\n无\n404\n\n\n情况 4（推荐）\nwww.sunboy.ltd\nblog.sunboy.ltd\n源站域名 blog.sunboy.ltd\n有（blog.sunboy.ltd）\n正常访问\n\n\n\n情况3访问失败原因分析：默认源站域名（如 blogggg-e3d9muwx.edgeone.run）：仅用于 EO Pages 的初始测试或内部转发，源站服务器未将其配置为有效 HOST 头，因此回源时无法匹配到站点资源。\n最后叨叨\n个人纯小白，全程豆包搜索，仅做个人成功案例分享，大佬勿喷。\n","categories":["一些乱七八糟"],"tags":["腾讯云","EdgeOne","源站域名","回源HOST头"]},{"title":"秋尾闲游","url":"/posts/f6b9d38c/","content":"前言\n最近家里这边秋雨连绵，从国庆以来几乎没见过太阳，也是让我体验了一波“烟雨江南”的感觉。但眼瞅着树上的叶子都快落完了，还是不见天晴，心里不免有些着急，好在本周难得的晴了一两天，赶紧出门记录2025秋的颜色。\n正文\n首先是我们县城的一个小景区，这是最近在出差的闲暇之余拍的，遗憾的是没带上我的宝贝Z502，只能用手机记录了。这个景区主要是一个由地下水形成的大水池，我去的时候是偏下午时候，阳光撒到水面的时候，近看发现整个水池呈现出一种绸缎的质感，远看星光闪闪，恰有几只大鹅游过，又是增添了几分梦幻的感觉。也是在这个景区，我体验了人生中第一次钓鱼的快乐，可能是有新手加成，出手就钓上来两条，不过都是那种小鱼。在这期间也发生了比较有意思的事情，景区的老板养了一只三花猫，很是可爱，我们就给了它一条鱼，没想到过了一会了它又连偷我们两条鱼，好一个三花大盗。\n\n    [{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154041.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154046.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154045.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154044.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154043.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154042.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154040.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154039.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154038.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154037.avif\",\"alt\":\"\",\"title\":\"\"}]\n  \n周六终于如愿以偿，拿上相机骑上小电驴就出发了，去到公园就是一顿狂拍，小公园树木种类还是比较少，好在有几颗银杏树，还有枫树，顺便还打了一只呆鸟哈哈。不过我构图还是没什么进步，全景是一点不敢拍，只能拿长焦浑水摸鱼了。\n\n    [{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154036.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154035.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154034.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154032.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154031.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154030.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154029.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154028.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154027.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154026.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154025.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154024.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154023.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154022.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154021.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154020.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154019.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154018.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154017.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154016.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154015.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154014.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019131154013.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/gallery/2025%E7%A7%8B/20251019130948687.avif\",\"alt\":\"\",\"title\":\"\"}]\n  \n结语\n尼康24-200这个镜头还是局限性太大了，没有广角也没有微距，腾龙新出的18-300又很一般，眼馋适马的16-300好久了，可就是不出Z口的，希望有生之年能用上。。。\n","categories":["狂人日记"],"tags":["摄影","秋天","相册"]},{"title":"第一次拍月亮记录","url":"/posts/bf596b83/","content":"写前哔哔\n自从入手尼康Z502之后，人像拍了（媳妇友情出演），鸟也打了（呆鸽纯纯走地鸡），就是还没拍过月亮，看别人拍出的超级大月亮老是心痒痒的，于是下决心一定要找个15号拍出自己的月亮。\n初次错过\n由于立flag的时间实在是过早，导致我到本月农历15号时完全忘了拍月亮这回事，当时正热衷于重构博客，等到23点多回到卧室时才从阳台突然看见一轮满月在天上。可是当时懒病犯了，一拿时间太晚二拿当晚天气不好三拿十五的月亮十六圆当借口，最终也是没下去，但那天也是真正下定了 要拍月亮的决心。\n再次无语\n第二天也是在21点多，终于是熬到了天黑，我也是超窗外望去，奇怪的是并没有发现月亮，当时只是觉得那会天气不好，后来才知道那会太早了月亮还没升起来。但是自从那天之后，连着好几天都是阴天，难道这个月又拍不到了吗。\n柳暗花明\n在农历17号的下午，不经意抬头间发现当天万里无云，心想今天不就是难得的好机会吗，掏出手机打开天文通，果然当晚观月条件预测概率高达87%。也是回去立马准备好支架，按照B站梦者蓝先生的经验参数提前设置好拍摄参数：快门160，iso400，光圈f6.3\n\n这次特意下去迟了一些，一直等到22点叫上媳妇一块下楼。下去之后发现还是没有月亮，在15号那天看到月亮的那个方向今天确实什么都没有，难道又是天气不好，可是天上星星都一清二楚，一定是下去还是太早，这会月亮被楼挡住了。于是我循着天空中最亮的方向，朝着小区外走去，终于实在一栋楼的后边，一轮显得有些耀眼的明月出现在了眼前。\n激动的心，颤抖的手，支架也来不及拆开，直接相机开机，焦距拧到最大，手持相机按下了快门：\n\n放大后开清晰度还可以，就是感觉有点过亮了，于是一顿狂调参数，最后也是架上三脚架，裁切后得到了我比较满意的一张：\n\n由于是半画幅相机，再加上24200还是焦距太短，所以跟网上那些清晰的能数纹理的还是比不了，不过对我来已经是超预期了。\n最后也是献上我的参数：快门160  ISO 125 光圈f8 点测光 点对焦，最好配个三脚架，这次拍完后发现我的便携式三脚架用来架微单还是有点勉强，后边可能买一个稳固一点的相机专用三脚架。\n","categories":["狂人日记"],"tags":["摄影","月亮","星空","日记"]},{"title":"基于腾讯云COS自动生成相册","url":"/posts/30a04b24/","content":"写前哔哔\n由于butterfly自带的相册每次上传时都要经过一系列比较繁琐的过程，上传、创建页面、复制粘贴图片md链接、hexo三连，这对于我这种对于发照片需求比较大的人着实有些麻烦了，因此我想着为什么不在相册页面中利用腾讯云官方的api，自动获取对象存储中的照片并进行分类呢，苦于太小白了，只能请教AI。\n正片开始\n\n首先新建一个相册页面：\n\nhexo new page album\n\n然后在该页面的md文件中填入以下front-matter：\n\n---title: 相册date: 2025-08-26 22:54:10aside: falsecomments: falsetype: album---\n在[BlogRoot]]\\themes\\butterfly\\layout\\includes\\page目录下新建一个album.pug文件，并复制粘贴以下内容：\n方格流排列瀑布流排列// 2. 相册核心HTML结构.div.sb-album-container  // 相册头部（筛选栏 + 加载指示器）  .sb-album-header    // 文件夹筛选标签区    .sb-tag-section      .sb-tag-filters.sb-folder-tags        button.sb-tag-filter.sb-active(data-folder=&quot;latest&quot;) 最新        // 文件夹标签将通过JavaScript动态加载    // 加载状态指示器    .sb-loading-indicator      i.fas.fa-spinner.fa-spin      span 正在加载图片和文件夹...  // 图片画廊容器（图片动态加载）  .sb-album-gallery#sbAlbumGallery    // 图片将通过JavaScript动态加载到这里  // 分页控件  .sb-pagination#sbPagination    button.sb-pagination-btn#sbPrevPage(disabled) 上一页    .sb-page-info#sbPageInfo 第 1 页 / 共 1 页    button.sb-pagination-btn#sbNextPage(disabled) 下一页  // 图片预览模态框  .sb-modal.sb-album-modal#sbImageModal    span.sb-close-btn &amp;times;    // 图片导航按钮（上一张/下一张）    button.sb-nav-btn.sb-prev-img-btn(aria-label=&quot;上一张&quot;)      i.fas.fa-chevron-left    button.sb-nav-btn.sb-next-img-btn(aria-label=&quot;下一张&quot;)      i.fas.fa-chevron-right    // 图片缩放控制按钮    .sb-zoom-controls      button.sb-zoom-btn.sb-zoom-in(aria-label=&quot;放大&quot;)        i.fas.fa-search-plus      button.sb-zoom-btn.sb-zoom-out(aria-label=&quot;缩小&quot;)        i.fas.fa-search-minus      button.sb-zoom-btn.sb-zoom-reset(aria-label=&quot;重置缩放&quot;)        i.fas.fa-compress-arrows-alt    // 预览图片容器    .sb-modal-image-container      img.sb-modal-content.sb-album-modal-img#sbModalImage// 3. 相册完整CSS样式（确保与原效果一致）style.  /* 相册容器样式 - 强制隔离，避免与主题样式冲突 */  .sb-album-container &#123;    max-width: 1400px;    margin: 0 auto;    padding: 2rem 1rem;    overflow: visible !important;    isolation: isolate; /* 关键：样式完全隔离 */    min-height: 0; /* 不影响父容器高度计算 */    box-sizing: border-box; /* 确保padding不溢出 */    position: relative; /* 建立独立的z-index上下文 */    z-index: 1; /* 低于页脚z-index */  &#125;  /* 图片加载淡入动画 */  @keyframes sbFadeIn &#123;    from &#123;      opacity: 0;      transform: translateY(10px);    &#125;    to &#123;      opacity: 1;      transform: translateY(0);    &#125;  &#125;  /* 相册头部样式 */  .sb-album-container .sb-album-header &#123;    text-align: center;    margin-bottom: 2rem;  &#125;  .sb-album-container .sb-album-header h2 &#123;    font-size: 2.5rem;    margin-bottom: 0.5rem;    color: #333;  &#125;  .sb-album-container .sb-album-header p &#123;    color: #666;    margin-bottom: 1.5rem;  &#125;  /* 文件夹筛选标签样式 */  .sb-album-container .sb-tag-section &#123;    margin-bottom: 1.5rem;    padding: 0.5rem;    border-radius: 8px;    background-color: transparent;    .hover  &#125;  .sb-album-container .sb-tag-filters &#123;    display: flex;    flex-wrap: wrap;    gap: 0.5rem;    padding: 0.5rem;    justify-content: center;  &#125;  .sb-album-container .sb-tag-filter &#123;    padding: 0.4rem 1rem;    border: none;    border-radius: 20px;    background-color: var(--btn-bg);    color: var(--btn-color);    text-align: center;;    font-size: 0.9rem;    cursor: pointer;    transition: all 0.3s ease;  &#125;  .sb-album-container .sb-tag-filter:hover &#123;    background-color: var(--btn-hover-color);  &#125;  .sb-album-container .sb-tag-filter.sb-active &#123;    background-color: var(--btn-hover-color);    color: white;  &#125;  /* 加载指示器样式 */  .sb-album-container .sb-loading-indicator &#123;    display: flex;    align-items: center;    justify-content: center;    gap: 0.5rem;    color: #666;    padding: 2rem;  &#125;  /* 网格加载状态样式 */  .sb-album-container .sb-grid-loading &#123;    grid-column: 1 / -1;    display: flex;    align-items: center;    justify-content: center;    gap: 0.5rem;    color: #666;    padding: 4rem 2rem;  &#125;  /* 图片画廊网格样式 */  .sb-album-container .sb-album-gallery &#123;    display: grid;    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));    gap: 1.5rem;    margin-bottom: 2rem;  &#125;  /* 无图片提示样式 */  .sb-album-container .sb-no-images &#123;    grid-column: 1 / -1;    text-align: center;    padding: 4rem 2rem;    color: #999;  &#125;  .sb-album-container .sb-no-images i &#123;    font-size: 3rem;    margin-bottom: 1rem;    display: block;  &#125;  /* 图片项基础样式 */  .sb-album-container .sb-album-item &#123;    border-radius: 8px;    overflow: hidden;    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);    transition: transform 0.3s ease, box-shadow 0.3s ease;    cursor: pointer;    position: relative;    aspect-ratio: 4/3;  &#125;  /* 图片项加载/加载完成状态 */  .sb-album-container .sb-album-item-loading &#123;    opacity: 0;    visibility: hidden;  &#125;  .sb-album-container .sb-album-item-loaded &#123;    opacity: 1;    visibility: visible;  &#125;  .sb-album-container .sb-album-item:hover &#123;    transform: translateY(-5px);    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);  &#125;  /* 图片包裹层样式 */  .sb-album-container .sb-image-wrapper &#123;    width: 100%;    height: 100%;    position: relative;    overflow: hidden;  &#125;  /* 图片样式 */  .sb-album-container .sb-album-img &#123;    width: 100%;    height: 100%;    object-fit: cover;    transition: transform 0.5s ease;    min-width: 100%;    min-height: 100%;    filter: none !important; /* 防止主题滤镜影响 */  &#125;  /* 图片加载/加载完成动画 */  .sb-album-container .sb-album-img-loading &#123;    opacity: 0;  &#125;  .sb-album-container .sb-album-img-loaded &#123;    animation: sbFadeIn 0.5s ease forwards;  &#125;  .sb-album-container .sb-album-item:hover .sb-image-wrapper .sb-album-img &#123;    transform: scale(1.05);  &#125;  /* 图片hover遮罩层 */  .sb-album-container .sb-image-overlay &#123;    position: absolute;    bottom: 0;    left: 0;    right: 0;    background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));    padding: 0.8rem;    color: white;    transform: translateY(100%);    transition: transform 0.3s ease;    display: flex;    justify-content: center;    align-items: center;  &#125;  .sb-album-container .sb-album-item:hover .sb-image-overlay &#123;    transform: translateY(0);  &#125;  /* 图片信息标签样式 */  .sb-album-container .sb-image-info &#123;    display: flex;    flex-wrap: wrap;    gap: 0.5rem;    justify-content: center;  &#125;  .sb-album-container .sb-folder-tag &#123;    font-size: 0.8rem;    padding: 0.2rem 0.7rem;    border-radius: 4px;    background-color: rgba(56, 178, 172, 0.7);  &#125;  .sb-album-container .sb-date-tag &#123;    font-size: 0.8rem;    padding: 0.2rem 0.7rem;    border-radius: 4px;    background-color: rgba(100, 116, 139, 0.7);  &#125;  /* 分页控件样式 */  .sb-album-container .sb-pagination &#123;    display: none; /* 默认隐藏，有图片时分页显示 */    justify-content: center;    align-items: center;    gap: 1rem;    margin: 2rem 0;  &#125;  .sb-album-container .sb-pagination-btn &#123;    padding: 0.5rem 1rem;    border: none;    border-radius: 4px;    background-color: #38b2ac;    color: white;    cursor: pointer;    transition: background-color 0.3s ease;  &#125;  .sb-album-container .sb-pagination-btn:disabled &#123;    background-color: #a0aec0;    cursor: not-allowed;    opacity: 0.7;  &#125;  .sb-album-container .sb-pagination-btn:hover:not(:disabled) &#123;    background-color: #319795;  &#125;  .sb-album-container .sb-page-info &#123;    color: #666;    font-size: 0.9rem;  &#125;  /* 预览模态框基础样式 */  .sb-album-container .sb-album-modal &#123;    display: none;    position: fixed;    z-index: 1000;    left: 0;    top: 0;    width: 100%;    height: 100%;    background-color: rgba(0, 0, 0, 0.9);  &#125;  /* 预览图片容器 */  .sb-album-container .sb-modal-image-container &#123;    width: 100%;    height: 100%;    display: flex;    align-items: center;    justify-content: center;    cursor: zoom-out;    padding: 1rem;    box-sizing: border-box;    overflow: auto; /* 缩放后可滚动查看完整图片 */  &#125;  /* 预览图片样式 */  .sb-album-container .sb-album-modal-img &#123;    max-width: 95%;    max-height: 95%;    object-fit: contain;    transition: transform 0.1s ease; /* 平滑缩放过渡 */    transform-origin: center center; /* 从中心缩放 */  &#125;  /* 预览图片加载/加载完成动画 */  .sb-album-container .sb-modal-img-loading &#123;    opacity: 0;  &#125;  .sb-album-container .sb-modal-img-loaded &#123;    animation: sbFadeIn 0.3s ease forwards;  &#125;  /* 关闭按钮样式 */  .sb-album-container .sb-close-btn &#123;    position: absolute;    top: 1.5rem;    right: 2.5rem;    color: white;    font-size: 2.5rem;    font-weight: bold;    transition: 0.3s;    cursor: pointer;    z-index: 1001;  &#125;  .sb-album-container .sb-close-btn:hover &#123;    color: #bbb;    transform: scale(1.1);  &#125;  /* 预览页导航按钮样式 */  .sb-album-container .sb-nav-btn &#123;    position: absolute;    top: 50%;    transform: translateY(-50%);    background-color: rgba(0, 0, 0, 0.5);    color: white;    border: none;    width: 60px;    height: 60px;    border-radius: 50%;    font-size: 1.5rem;    cursor: pointer;    display: flex;    align-items: center;    justify-content: center;    transition: all 0.3s ease;    z-index: 1001;    opacity: 0.7;  &#125;  .sb-album-container .sb-nav-btn:hover &#123;    background-color: rgba(0, 0, 0, 0.8);    opacity: 1;    transform: translateY(-50%) scale(1.1);  &#125;  .sb-album-container .sb-prev-img-btn &#123;    left: 1rem;  &#125;  .sb-album-container .sb-next-img-btn &#123;    right: 1rem;  &#125;  /* 导航按钮禁用状态 */  .sb-album-container .sb-nav-btn.sb-disabled &#123;    opacity: 0.3;    cursor: not-allowed;  &#125;  .sb-album-container .sb-nav-btn.sb-disabled:hover &#123;    background-color: rgba(0, 0, 0, 0.5);    transform: translateY(-50%);  &#125;  /* 缩放控制按钮样式 */  .sb-album-container .sb-zoom-controls &#123;    position: absolute;    bottom: 2rem;    left: 50%;    transform: translateX(-50%);    display: flex;    gap: 0.5rem;    z-index: 1001;  &#125;  .sb-album-container .sb-zoom-btn &#123;    background-color: rgba(0, 0, 0, 0.5);    color: white;    border: none;    width: 40px;    height: 40px;    border-radius: 50%;    cursor: pointer;    display: flex;    align-items: center;    justify-content: center;    transition: all 0.3s ease;    opacity: 0.7;  &#125;  .sb-album-container .sb-zoom-btn:hover &#123;    background-color: rgba(0, 0, 0, 0.8);    opacity: 1;    transform: scale(1.1);  &#125;  /* 响应式适配（移动端） */  @media (max-width: 768px) &#123;    .sb-album-container .sb-album-gallery &#123;      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));    &#125;    .sb-album-container .sb-close-btn &#123;      top: 1rem;      right: 1.5rem;      font-size: 2rem;    &#125;    .sb-album-container .sb-tag-filter &#123;      padding: 0.3rem 0.8rem;      font-size: 0.8rem;    &#125;    .sb-album-container .sb-pagination &#123;      gap: 0.5rem;    &#125;    .sb-album-container .sb-pagination-btn &#123;      padding: 0.4rem 0.8rem;      font-size: 0.9rem;    &#125;    /* 移动端缩小导航按钮 */    .sb-album-container .sb-nav-btn &#123;      width: 40px;      height: 40px;      font-size: 1rem;    &#125;    /* 移动端缩小缩放按钮 */    .sb-album-container .sb-zoom-btn &#123;      width: 36px;      height: 36px;    &#125;  &#125;  /* 模态框打开时禁止页面滚动 */  body.sb-modal-open &#123;    overflow: hidden !important;  &#125;// 4. 相册完整JavaScript逻辑（关联主题配置中的私密信息）script.  // 直接在这里定义配置（替换为你的实际信息）  const SB_ALBUM_CONFIG = &#123;    COS_SCRIPT_URL: &quot;https://cdn.jsdmirror.com/npm/cos-js-sdk-v5@1.4.5/dist/cos-js-sdk-v5.min.js&quot;,    RETRY: &#123;      MAX_COUNT: 10,      INTERVAL: 1000,      INIT_TIMEOUT: 20000    &#125;,    // 直接硬编码配置（替换为你的实际值）    IMAGES_PER_PAGE: #&#123;theme.album.page.images_per_page&#125;,    ZOOM: &#123;      MIN: 0.1,      MAX: 5,      STEP: 0.1,      DEFAULT: 1    &#125;,    ANIMATION: &#123;      FADE_IN_DELAY: 80,      FADE_IN_DURATION: 500    &#125;  &#125;;  const sbAlbum = &#123;    // 关键：从主题配置获取COS私密信息（避免硬编码）    cosConfig: &#123;      Bucket: &#x27;#&#123;theme.album.cos.bucket&#125;&#x27;,       // COS Bucket（主题配置）      Region: &#x27;#&#123;theme.album.cos.region&#125;&#x27;,       // COS地域（主题配置）      RootFolder: &#x27;#&#123;theme.album.cos.root_folder&#125;&#x27;, // COS根文件夹（主题配置）      CdnDomain: &#x27;#&#123;theme.album.cos.cdn_domain&#125;&#x27;, // CDN域名（主题配置）      SecretId: &#x27;#&#123;theme.album.cos.secret_id&#125;&#x27;,   // 私密SecretId（主题配置）      SecretKey: &#x27;#&#123;theme.album.cos.secret_key&#125;&#x27;  // 私密SecretKey（主题配置）    &#125;,    // 加载状态管理    loadState: &#123;      isCosLoaded: false,      isAlbumInit: false,      isLoading: false,      retryCount: 0,      initTimeout: null    &#125;,    // 核心数据存储    cos: null,    allImages: [],         // 所有图片（按时间排序）    filteredImages: [],    // 当前筛选后的图片    allFolders: new Set(), // 所有文件夹    currentFolder: &#x27;latest&#x27;, // 当前选中文件夹（默认&quot;最新&quot;）    currentPage: 1,        // 当前页码    totalPages: 1,         // 总页数    loadedImageKeys: new Set(), // 已加载的图片Key（避免重复）    // 预览相关状态    currentPreviewIndex: -1,    // 当前预览图片的索引    currentZoomLevel: SB_ALBUM_CONFIG.ZOOM.DEFAULT, // 当前缩放级别    // DOM元素缓存    elements: &#123;&#125;,    // 初始化入口    init() &#123;      if (this.loadState.isAlbumInit || this.loadState.isLoading) return;      this.resetState();      // 获取相册容器（确保DOM已加载）      this.elements.container = document.querySelector(&#x27;.sb-album-container&#x27;);      if (!this.elements.container) &#123;        console.warn(&quot;未找到相册容器，100ms后重试&quot;);        setTimeout(() =&gt; this.init(), 100);        return;      &#125;      // 缓存所有需要操作的DOM元素      this.elements.gallery = this.elements.container.querySelector(&#x27;#sbAlbumGallery&#x27;);      this.elements.loadingIndicator = this.elements.container.querySelector(&#x27;.sb-loading-indicator&#x27;);      this.elements.folderTagFilters = this.elements.container.querySelector(&#x27;.sb-folder-tags&#x27;);      this.elements.modal = this.elements.container.querySelector(&#x27;#sbImageModal&#x27;);      this.elements.modalImage = this.elements.container.querySelector(&#x27;#sbModalImage&#x27;);      this.elements.modalImageContainer = this.elements.container.querySelector(&#x27;.sb-modal-image-container&#x27;);      this.elements.closeBtn = this.elements.container.querySelector(&#x27;.sb-close-btn&#x27;);      this.elements.pagination = this.elements.container.querySelector(&#x27;#sbPagination&#x27;);      this.elements.prevPageBtn = this.elements.container.querySelector(&#x27;#sbPrevPage&#x27;);      this.elements.nextPageBtn = this.elements.container.querySelector(&#x27;#sbNextPage&#x27;);      this.elements.pageInfo = this.elements.container.querySelector(&#x27;#sbPageInfo&#x27;);      this.elements.prevImgBtn = this.elements.container.querySelector(&#x27;.sb-prev-img-btn&#x27;);      this.elements.nextImgBtn = this.elements.container.querySelector(&#x27;.sb-next-img-btn&#x27;);      this.elements.zoomInBtn = this.elements.container.querySelector(&#x27;.sb-zoom-in&#x27;);      this.elements.zoomOutBtn = this.elements.container.querySelector(&#x27;.sb-zoom-out&#x27;);      this.elements.zoomResetBtn = this.elements.container.querySelector(&#x27;.sb-zoom-reset&#x27;);      // 绑定所有事件      this.bindEvents();      // 启动加载流程      this.startLoadingProcess();      // 标记初始化完成      this.loadState.isAlbumInit = true;    &#125;,    // 启动加载流程（加载COS SDK + 初始化COS）    startLoadingProcess() &#123;      this.loadState.isLoading = true;      this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;正在加载资源...&lt;/span&gt;&#x27;);      // 若COS已加载，直接初始化；否则加载SDK      if (window.COS) &#123;        this.loadState.isCosLoaded = true;        this.initializeCosAndLoadImages();        return;      &#125;      // 加载COS SDK（带重试机制）      this.loadCosSdk()        .then(() =&gt; this.initializeCosAndLoadImages())        .catch(err =&gt; &#123;          console.error(&#x27;COS SDK加载失败:&#x27;, err);          this.retryLoadCosSdk();        &#125;);    &#125;,    // 初始化COS客户端并加载图片/文件夹    initializeCosAndLoadImages() &#123;      try &#123;        // 初始化COS客户端        this.cos = new COS(&#123;          SecretId: this.cosConfig.SecretId,          SecretKey: this.cosConfig.SecretKey        &#125;);        // 更新加载状态        this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;正在加载图片和文件夹...&lt;/span&gt;&#x27;);        // 加载COS中的图片和文件夹        this.getCosImagesAndFolders()          .then(() =&gt; this.loadState.isLoading = false)          .catch(err =&gt; &#123;            console.error(&#x27;加载图片失败:&#x27;, err);            this.loadState.isLoading = false;            this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;&lt;span&gt;加载图片失败，请重试&lt;/span&gt;&#x27;);          &#125;);      &#125; catch (err) &#123;        console.error(&#x27;初始化COS失败:&#x27;, err);        this.loadState.isLoading = false;        this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;&lt;span&gt;初始化失败，请重试&lt;/span&gt;&#x27;);      &#125;    &#125;,    // 加载COS SDK（Promise封装）    loadCosSdk() &#123;      return new Promise((resolve, reject) =&gt; &#123;        // 清除已有超时器        if (this.loadState.initTimeout) clearTimeout(this.loadState.initTimeout);        // 设置加载超时        this.loadState.initTimeout = setTimeout(() =&gt; &#123;          reject(new Error(`COS SDK加载超时`));        &#125;, SB_ALBUM_CONFIG.RETRY.INIT_TIMEOUT);        // 检查SDK是否已加载        let cosScript = document.querySelector(`script[src=&quot;$&#123;SB_ALBUM_CONFIG.COS_SCRIPT_URL&#125;&quot;]`);        if (cosScript) &#123;          // 轮询检查SDK是否就绪          const checkLoaded = () =&gt; &#123;            if (window.COS) &#123;              clearTimeout(this.loadState.initTimeout);              this.loadState.isCosLoaded = true;              resolve();            &#125; else &#123;              setTimeout(checkLoaded, 100);            &#125;          &#125;;          checkLoaded();          return;        &#125;        // 动态创建SDK脚本        cosScript = document.createElement(&quot;script&quot;);        cosScript.src = SB_ALBUM_CONFIG.COS_SCRIPT_URL;        cosScript.type = &quot;text/javascript&quot;;        // 加载成功回调        cosScript.onload = () =&gt; &#123;          clearTimeout(this.loadState.initTimeout);          this.loadState.isCosLoaded = true;          resolve();        &#125;;        // 加载失败回调        cosScript.onerror = (err) =&gt; &#123;          clearTimeout(this.loadState.initTimeout);          reject(new Error(`COS SDK加载失败: $&#123;err.message&#125;`));        &#125;;        // 插入脚本到头部        document.head.appendChild(cosScript);      &#125;);    &#125;,    // 重试加载COS SDK（带次数限制）    retryLoadCosSdk() &#123;      if (this.loadState.retryCount &gt;= SB_ALBUM_CONFIG.RETRY.MAX_COUNT) &#123;        this.loadState.isLoading = false;        this.updateLoadingIndicator(`          &lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;          &lt;span&gt;无法加载必要组件，请检查网络后刷新页面&lt;/span&gt;        `);        return;      &#125;      // 增加重试次数并更新状态      this.loadState.retryCount++;      this.updateLoadingIndicator(`        &lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;        &lt;span&gt;正在重试加载（$&#123;this.loadState.retryCount&#125;/$&#123;SB_ALBUM_CONFIG.RETRY.MAX_COUNT&#125;）...&lt;/span&gt;      `);      // 延迟重试      setTimeout(() =&gt; &#123;        this.loadCosSdk()          .then(() =&gt; this.initializeCosAndLoadImages())          .catch(() =&gt; this.retryLoadCosSdk());      &#125;, SB_ALBUM_CONFIG.RETRY.INTERVAL);    &#125;,    // 从COS获取图片和文件夹列表    async getCosImagesAndFolders() &#123;      try &#123;        // 调用COS API获取文件列表        const listResult = await new Promise((resolve, reject) =&gt; &#123;          this.cos.getBucket(&#123;            Bucket: this.cosConfig.Bucket,            Region: this.cosConfig.Region,            Prefix: this.cosConfig.RootFolder,            MaxKeys: 1000 // 单次最大获取数量（可根据需求调整）          &#125;, (err, data) =&gt; err ? reject(err) : resolve(data));        &#125;);        // 提取图片和文件夹信息        const imageItems = [];        const rootLength = this.cosConfig.RootFolder.length;        // 遍历COS返回的文件列表        listResult.Contents.forEach(item =&gt; &#123;          // 跳过已加载的图片（避免重复）          if (this.loadedImageKeys.has(item.Key)) return;          // 检查是否为图片文件（通过后缀名判断）          const ext = item.Key.split(&#x27;.&#x27;).pop()?.toLowerCase();          const isImage = ext &amp;&amp; [&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;, &#x27;webp&#x27;, &#x27;avif&#x27;].includes(ext);          if (isImage) &#123;            // 提取文件夹名称（若有）            const pathWithoutRoot = item.Key.substring(rootLength);            const folderSeparatorIndex = pathWithoutRoot.indexOf(&#x27;/&#x27;);            let folder = &#x27;未分类&#x27;; // 默认文件夹            // 若存在文件夹分隔符，提取文件夹名            if (folderSeparatorIndex &gt; 0) &#123;              folder = pathWithoutRoot.substring(0, folderSeparatorIndex);            &#125;            // 存储图片信息            imageItems.push(&#123;              key: item.Key,              url: `$&#123;this.cosConfig.CdnDomain&#125;/$&#123;item.Key&#125;`, // 图片CDN链接              name: item.Key.split(&#x27;/&#x27;).pop().split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;), // 图片名称（不含后缀）              folder: folder, // 所属文件夹              lastModified: new Date(item.LastModified) // 最后修改时间（用于排序）            &#125;);            // 记录文件夹和已加载图片            this.allFolders.add(folder);            this.loadedImageKeys.add(item.Key);          &#125;        &#125;);        // 处理无图片场景        if (imageItems.length === 0) &#123;          this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-image text-gray-400&quot;&gt;&lt;/i&gt;&lt;span&gt;未找到图片&lt;/span&gt;&#x27;);          this.updatePagination(0); // 隐藏分页          return;        &#125;        // 按修改时间排序（最新在前）        this.allImages = imageItems.sort((a, b) =&gt; b.lastModified - a.lastModified);        // 隐藏加载指示器        if (this.elements.loadingIndicator) &#123;          this.elements.loadingIndicator.style.display = &#x27;none&#x27;;        &#125;        // 渲染文件夹筛选标签、筛选图片、更新分页、显示图片        this.displayFolderTagFilters();        this.filterImages();        this.updatePagination(this.filteredImages.length);        this.displayCurrentPageImages();      &#125; catch (err) &#123;        console.error(&#x27;获取图片列表失败:&#x27;, err);        throw err;      &#125;    &#125;,    // 渲染文件夹筛选标签    displayFolderTagFilters() &#123;      if (!this.elements.folderTagFilters) return;      // 清除现有标签（保留&quot;最新&quot;标签）      Array.from(this.elements.folderTagFilters.children).forEach(child =&gt; &#123;        if (child.dataset.folder !== &#x27;latest&#x27;) child.remove();      &#125;);      // 为每个文件夹创建筛选标签      Array.from(this.allFolders).forEach(folder =&gt; &#123;        const tagBtn = document.createElement(&#x27;button&#x27;);        tagBtn.className = &#x27;sb-tag-filter&#x27;;        tagBtn.dataset.folder = folder;        tagBtn.textContent = folder;        // 绑定筛选事件        tagBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.handleFolderTagClick(folder));        this.elements.folderTagFilters.appendChild(tagBtn);      &#125;);    &#125;,    // 文件夹筛选标签点击事件    handleFolderTagClick(folder) &#123;      this.currentFolder = folder;      this.currentPage = 1; // 切换文件夹时重置到第一页      // 显示加载状态      this.elements.gallery.innerHTML = `        &lt;div class=&quot;sb-grid-loading&quot;&gt;          &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;          &lt;span&gt;正在加载$&#123;folder&#125;分类的图片...&lt;/span&gt;        &lt;/div&gt;      `;      // 更新筛选标签活跃状态      this.elements.container.querySelectorAll(&#x27;.sb-folder-tags .sb-tag-filter&#x27;).forEach(btn =&gt; &#123;        btn.classList.remove(&#x27;sb-active&#x27;);      &#125;);      this.elements.container.querySelector(`.sb-folder-tags .sb-tag-filter[data-folder=&quot;$&#123;folder&#125;&quot;]`)?.classList.add(&#x27;sb-active&#x27;);      // 延迟处理（确保加载状态显示）      setTimeout(() =&gt; &#123;        this.filterImages();        this.updatePagination(this.filteredImages.length);        this.displayCurrentPageImages();      &#125;, 300);    &#125;,    // 筛选当前文件夹的图片    filterImages() &#123;      if (this.currentFolder === &#x27;latest&#x27;) &#123;        // &quot;最新&quot;分类：显示所有图片        this.filteredImages = [...this.allImages];      &#125; else &#123;        // 特定文件夹：筛选对应图片        this.filteredImages = this.allImages.filter(image =&gt; image.folder === this.currentFolder);      &#125;    &#125;,    // 更新分页信息（总页数、按钮状态）    updatePagination(totalItems) &#123;      if (!this.elements.pagination) return;      // 计算总页数      this.totalPages = Math.max(1, Math.ceil(totalItems / SB_ALBUM_CONFIG.IMAGES_PER_PAGE));      // 更新页码文本      this.elements.pageInfo.textContent = `第 $&#123;this.currentPage&#125; 页 / 共 $&#123;this.totalPages&#125; 页`;      // 更新分页按钮禁用状态      this.elements.prevPageBtn.disabled = this.currentPage &lt;= 1;      this.elements.nextPageBtn.disabled = this.currentPage &gt;= this.totalPages;      // 只有一页时隐藏分页      this.elements.pagination.style.display = this.totalPages &lt;= 1 ? &#x27;none&#x27; : &#x27;flex&#x27;;    &#125;,    // 显示当前页的图片（带逐张淡入动画）    displayCurrentPageImages() &#123;      if (!this.elements.gallery) return;      this.elements.gallery.innerHTML = &#x27;&#x27;;      // 计算当前页图片的索引范围      const startIndex = (this.currentPage - 1) * SB_ALBUM_CONFIG.IMAGES_PER_PAGE;      const endIndex = startIndex + SB_ALBUM_CONFIG.IMAGES_PER_PAGE;      const currentPageImages = this.filteredImages.slice(startIndex, endIndex);      // 处理当前页无图片场景      if (currentPageImages.length === 0) &#123;        const message = this.filteredImages.length === 0          ? &#x27;暂无图片&#x27;          : `在&quot;$&#123;this.currentFolder&#125;&quot;中没有更多图片`;        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-no-images&quot;&gt;            &lt;i class=&quot;fas fa-search text-gray-300&quot;&gt;&lt;/i&gt;            &lt;p&gt;$&#123;message&#125;&lt;/p&gt;          &lt;/div&gt;        `;        return;      &#125;      // 批量创建图片元素（用DocumentFragment优化性能）      const fragment = document.createDocumentFragment();      currentPageImages.forEach((image, index) =&gt; &#123;        // 创建图片项容器        const imageCard = document.createElement(&#x27;div&#x27;);        imageCard.className = &#x27;sb-album-item sb-album-item-loading&#x27;; // 初始加载状态        imageCard.dataset.folder = image.folder;        imageCard.dataset.imageKey = image.key;        imageCard.dataset.index = startIndex + index; // 记录在筛选列表中的索引        // 格式化日期显示（YYYY-MM-DD）        const formattedDate = this.formatDate(image.lastModified);        // 图片项HTML结构        imageCard.innerHTML = `          &lt;div class=&quot;sb-image-wrapper&quot;&gt;            &lt;!-- 占位图（避免布局抖动） --&gt;            &lt;img src=&quot;data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 200 200&#x27;%3E%3Crect width=&#x27;200&#x27; height=&#x27;200&#x27; fill=&#x27;%23f3f4f6&#x27;/%3E%3C/svg%3E&quot;                 data-src=&quot;$&#123;image.url&#125;&quot;                 alt=&quot;$&#123;image.name&#125;&quot;                 class=&quot;lazyload sb-album-img sb-album-img-loading&quot;&gt;            &lt;!-- 图片hover遮罩 --&gt;            &lt;div class=&quot;sb-image-overlay&quot;&gt;              &lt;div class=&quot;sb-image-info&quot;&gt;                &lt;span class=&quot;sb-folder-tag&quot;&gt;$&#123;image.folder&#125;&lt;/span&gt;                &lt;span class=&quot;sb-date-tag&quot;&gt;$&#123;formattedDate&#125;&lt;/span&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        `;        // 绑定预览事件        imageCard.addEventListener(&#x27;click&#x27;, () =&gt; &#123;          const imageIndex = parseInt(imageCard.dataset.index);          this.openImageModal(image.url, imageIndex);        &#125;);        fragment.appendChild(imageCard);      &#125;);      // 批量插入图片项      this.elements.gallery.appendChild(fragment);      // 初始化懒加载      this.initThemeLazyLoad();      // 逐张显示图片（添加淡入动画）      const imageItems = this.elements.gallery.querySelectorAll(&#x27;.sb-album-item&#x27;);      imageItems.forEach((item, index) =&gt; &#123;        setTimeout(() =&gt; &#123;          // 移除加载状态，添加加载完成状态          item.classList.remove(&#x27;sb-album-item-loading&#x27;);          item.classList.add(&#x27;sb-album-item-loaded&#x27;);          // 图片加载完成后添加淡入动画          const img = item.querySelector(&#x27;.sb-album-img&#x27;);          if (img.complete) &#123;            img.classList.remove(&#x27;sb-album-img-loading&#x27;);            img.classList.add(&#x27;sb-album-img-loaded&#x27;);          &#125; else &#123;            img.addEventListener(&#x27;load&#x27;, () =&gt; &#123;              img.classList.remove(&#x27;sb-album-img-loading&#x27;);              img.classList.add(&#x27;sb-album-img-loaded&#x27;);            &#125;);          &#125;        &#125;, index * SB_ALBUM_CONFIG.ANIMATION.FADE_IN_DELAY);      &#125;);      // 滚动到相册顶部（提升体验）      window.scrollTo(&#123; top: this.elements.container.offsetTop - 20, behavior: &#x27;smooth&#x27; &#125;);    &#125;,    // 上一页    prevPage() &#123;      if (this.currentPage &gt; 1) &#123;        // 显示加载状态        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-grid-loading&quot;&gt;            &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;            &lt;span&gt;正在加载上一页图片...&lt;/span&gt;          &lt;/div&gt;        `;        // 更新页码        this.currentPage--;        // 更新分页信息        this.updatePagination(this.filteredImages.length);        // 延迟加载（确保加载状态显示）        setTimeout(() =&gt; &#123;          this.displayCurrentPageImages();        &#125;, 300);      &#125;    &#125;,    // 下一页    nextPage() &#123;      if (this.currentPage &lt; this.totalPages) &#123;        // 显示加载状态        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-grid-loading&quot;&gt;            &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;            &lt;span&gt;正在加载下一页图片...&lt;/span&gt;          &lt;/div&gt;        `;        // 更新页码        this.currentPage++;        // 更新分页信息        this.updatePagination(this.filteredImages.length);        // 延迟加载（确保加载状态显示）        setTimeout(() =&gt; &#123;          this.displayCurrentPageImages();        &#125;, 300);      &#125;    &#125;,    // 格式化日期（YYYY-MM-DD）    formatDate(date) &#123;      const year = date.getFullYear();      const month = String(date.getMonth() + 1).padStart(2, &#x27;0&#x27;);      const day = String(date.getDate()).padStart(2, &#x27;0&#x27;);      return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;    &#125;,    // 初始化懒加载（兼容主题自带懒加载）    initThemeLazyLoad() &#123;      if (window.LazyLoad) &#123;        // 若主题已加载LazyLoad，用主题的懒加载        new LazyLoad(&#123;          elements_selector: &#x27;.sb-album-container img.lazyload&#x27;,          threshold: 300        &#125;);      &#125; else if (window.lazyLoadInstance) &#123;        // 若主题有懒加载实例，更新实例        window.lazyLoadInstance.update();      &#125; else &#123;        //  fallback：直接加载图片        setTimeout(() =&gt; &#123;          document.querySelectorAll(&#x27;.sb-album-container img.lazyload&#x27;).forEach(img =&gt; &#123;            if (img.dataset.src &amp;&amp; img.src !== img.dataset.src) &#123;              img.src = img.dataset.src;              img.classList.remove(&#x27;lazyload&#x27;);            &#125;          &#125;);        &#125;, 500);      &#125;    &#125;,    // 打开图片预览模态框    openImageModal(url, index) &#123;      if (!this.elements.modal || !this.elements.modalImage) return;      // 记录当前预览图片的索引      this.currentPreviewIndex = index;      // 重置缩放级别      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();      // 先设置透明占位图（避免布局抖动）      this.elements.modalImage.src = &#x27;data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;1&quot; height=&quot;1&quot;%3E%3Crect width=&quot;1&quot; height=&quot;1&quot; fill=&quot;transparent&quot;/%3E%3C/svg%3E&#x27;;      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 显示模态框      this.elements.modal.style.display = &#x27;block&#x27;;      // 禁止页面滚动      document.body.classList.add(&#x27;sb-modal-open&#x27;);      // 预加载图片（提升体验）      const img = new Image();      img.onload = () =&gt; &#123;        this.elements.modalImage.src = url;        // 图片加载完成后添加淡入动画        setTimeout(() =&gt; &#123;          this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);          this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);        &#125;, 50);      &#125;;      img.src = url;      // 更新预览导航按钮状态      this.updateNavButtonsState();    &#125;,    // 关闭图片预览模态框    closeImageModal() &#123;      if (!this.elements.modal) return;      // 隐藏模态框      this.elements.modal.style.display = &#x27;none&#x27;;      // 恢复页面滚动      document.body.classList.remove(&#x27;sb-modal-open&#x27;);      // 重置缩放和动画状态      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);    &#125;,    // 预览页：上一张图片    prevImage() &#123;      if (this.currentPreviewIndex &lt;= 0) return;      // 隐藏当前图片（过渡效果）      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 延迟加载下一张（确保过渡效果可见）      setTimeout(() =&gt; &#123;        // 更新预览索引        this.currentPreviewIndex--;        const prevImage = this.filteredImages[this.currentPreviewIndex];        // 预加载上一张图片        const img = new Image();        img.onload = () =&gt; &#123;          this.elements.modalImage.src = prevImage.url;          // 图片加载完成后显示          setTimeout(() =&gt; &#123;            this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);            this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);          &#125;, 50);        &#125;;        img.src = prevImage.url;        // 重置缩放        this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;        this.updateImageZoom();        // 更新导航按钮状态        this.updateNavButtonsState();      &#125;, 200);    &#125;,    // 预览页：下一张图片    nextImage() &#123;      if (this.currentPreviewIndex &gt;= this.filteredImages.length - 1) return;      // 隐藏当前图片（过渡效果）      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 延迟加载下一张（确保过渡效果可见）      setTimeout(() =&gt; &#123;        // 更新预览索引        this.currentPreviewIndex++;        const nextImage = this.filteredImages[this.currentPreviewIndex];        // 预加载下一张图片        const img = new Image();        img.onload = () =&gt; &#123;          this.elements.modalImage.src = nextImage.url;          // 图片加载完成后显示          setTimeout(() =&gt; &#123;            this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);            this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);          &#125;, 50);        &#125;;        img.src = nextImage.url;        // 重置缩放        this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;        this.updateImageZoom();        // 更新导航按钮状态        this.updateNavButtonsState();      &#125;, 200);    &#125;,    // 更新预览页导航按钮状态（禁用/启用）    updateNavButtonsState() &#123;      // 第一页：禁用上一张      this.elements.prevImgBtn.disabled = this.currentPreviewIndex &lt;= 0;      // 最后一页：禁用下一张      this.elements.nextImgBtn.disabled = this.currentPreviewIndex &gt;= this.filteredImages.length - 1;      // 添加禁用视觉样式      if (this.currentPreviewIndex &lt;= 0) &#123;        this.elements.prevImgBtn.classList.add(&#x27;sb-disabled&#x27;);      &#125; else &#123;        this.elements.prevImgBtn.classList.remove(&#x27;sb-disabled&#x27;);      &#125;      if (this.currentPreviewIndex &gt;= this.filteredImages.length - 1) &#123;        this.elements.nextImgBtn.classList.add(&#x27;sb-disabled&#x27;);      &#125; else &#123;        this.elements.nextImgBtn.classList.remove(&#x27;sb-disabled&#x27;);      &#125;    &#125;,    // 图片放大    zoomIn() &#123;      if (this.currentZoomLevel &lt; SB_ALBUM_CONFIG.ZOOM.MAX) &#123;        this.currentZoomLevel += SB_ALBUM_CONFIG.ZOOM.STEP;        this.updateImageZoom();      &#125;    &#125;,    // 图片缩小    zoomOut() &#123;      if (this.currentZoomLevel &gt; SB_ALBUM_CONFIG.ZOOM.MIN) &#123;        this.currentZoomLevel -= SB_ALBUM_CONFIG.ZOOM.STEP;        this.updateImageZoom();      &#125;    &#125;,    // 重置图片缩放    resetZoom() &#123;      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();    &#125;,    // 应用图片缩放（更新DOM样式）    updateImageZoom() &#123;      if (this.elements.modalImage) &#123;        this.elements.modalImage.style.transform = `scale($&#123;this.currentZoomLevel&#125;)`;      &#125;    &#125;,    // 绑定所有交互事件    bindEvents() &#123;      // 分页按钮事件      if (this.elements.prevPageBtn) &#123;        this.elements.prevPageBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.prevPage());      &#125;      if (this.elements.nextPageBtn) &#123;        this.elements.nextPageBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.nextPage());      &#125;      // 预览页导航按钮事件      if (this.elements.prevImgBtn) &#123;        this.elements.prevImgBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation(); // 阻止事件冒泡          this.prevImage();        &#125;);      &#125;      if (this.elements.nextImgBtn) &#123;        this.elements.nextImgBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.nextImage();        &#125;);      &#125;      // 缩放控制按钮事件      if (this.elements.zoomInBtn) &#123;        this.elements.zoomInBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.zoomIn();        &#125;);      &#125;      if (this.elements.zoomOutBtn) &#123;        this.elements.zoomOutBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.zoomOut();        &#125;);      &#125;      if (this.elements.zoomResetBtn) &#123;        this.elements.zoomResetBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.resetZoom();        &#125;);      &#125;      // 预览图片容器点击事件（关闭模态框）      if (this.elements.modalImageContainer) &#123;        this.elements.modalImageContainer.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          e.preventDefault();          this.closeImageModal();        &#125;);      &#125;      // 模态框点击事件（点击背景关闭）      if (this.elements.modal) &#123;        this.elements.modal.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          if (e.target === this.elements.modal) &#123;            this.closeImageModal();          &#125;        &#125;);        // 滚轮缩放事件        this.elements.modal.addEventListener(&#x27;wheel&#x27;, (e) =&gt; &#123;          e.preventDefault();          e.stopPropagation();          // 滚轮向上：放大；向下：缩小          if (e.deltaY &lt; 0) &#123;            this.zoomIn();          &#125; else &#123;            this.zoomOut();          &#125;        &#125;, &#123; passive: false &#125;);        // 键盘导航事件        this.elements.modal.addEventListener(&#x27;keydown&#x27;, (e) =&gt; &#123;          switch (e.key) &#123;            case &#x27;ArrowLeft&#x27;: // 左箭头：上一张              e.preventDefault();              this.prevImage();              break;            case &#x27;ArrowRight&#x27;: // 右箭头：下一张              e.preventDefault();              this.nextImage();              break;            case &#x27;Escape&#x27;: // ESC：关闭模态框              e.preventDefault();              this.closeImageModal();              break;            case &#x27;+&#x27;: // 加号：放大            case &#x27;=&#x27;:              e.preventDefault();              this.zoomIn();              break;            case &#x27;-&#x27;: // 减号：缩小              e.preventDefault();              this.zoomOut();              break;            case &#x27;0&#x27;: // 0：重置缩放              e.preventDefault();              this.resetZoom();              break;          &#125;        &#125;);      &#125;      // 关闭按钮事件      if (this.elements.closeBtn) &#123;        this.elements.closeBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.closeImageModal();        &#125;);      &#125;      // 预览图片加载失败处理      if (this.elements.modalImage) &#123;        this.elements.modalImage.addEventListener(&#x27;error&#x27;, (e) =&gt; &#123;          e.stopPropagation();          // 加载失败时显示占位图          this.elements.modalImage.src = &#x27;data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 300 200&quot;%3E%3Crect width=&quot;300&quot; height=&quot;200&quot; fill=&quot;%23333&quot;/%3E%3Ctext x=&quot;50%&quot; y=&quot;50%&quot; dominant-baseline=&quot;middle&quot; text-anchor=&quot;middle&quot; fill=&quot;%23fff&quot;%3E图片无法加载%3C/text%3E%3C/svg%3E&#x27;;          this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);          this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);        &#125;);      &#125;      // &quot;最新&quot;标签点击事件      if (this.elements.folderTagFilters) &#123;        const latestBtn = this.elements.folderTagFilters.querySelector(&#x27;.sb-tag-filter[data-folder=&quot;latest&quot;]&#x27;);        if (latestBtn) &#123;          latestBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.handleFolderTagClick(&#x27;latest&#x27;));        &#125;      &#125;    &#125;,    // 重置相册状态（用于重新初始化）    resetState() &#123;      this.allImages = [];      this.filteredImages = [];      this.allFolders.clear();      this.currentFolder = &#x27;latest&#x27;;      this.currentPage = 1;      this.totalPages = 1;      this.currentPreviewIndex = -1;      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.loadedImageKeys.clear();      this.elements = &#123;&#125;;      this.cos = null;      // 重置加载状态      this.loadState = &#123;        isCosLoaded: window.COS ? true : false,        isAlbumInit: false,        isLoading: false,        retryCount: 0,        initTimeout: null      &#125;;      // 恢复页面滚动      document.body.classList.remove(&#x27;sb-modal-open&#x27;);    &#125;,    // 更新加载指示器文本    updateLoadingIndicator(html) &#123;      const loadingEl = this.elements.loadingIndicator || document.querySelector(&#x27;.sb-album-container .sb-loading-indicator&#x27;);      if (loadingEl) &#123;        loadingEl.innerHTML = html;        loadingEl.style.display = &#x27;flex&#x27;;      &#125;    &#125;,    // 销毁相册（释放资源）    destroy() &#123;      this.resetState();      if (this.elements.modal) &#123;        this.elements.modal.style.display = &#x27;none&#x27;;      &#125;    &#125;  &#125;;  // 相册初始化函数（兼容DOM加载和主题Pjax）  function initSbAlbum() &#123;    sbAlbum.destroy(); // 先销毁旧实例，避免重复    // 若DOM未加载完成，等待DOM加载    if (document.readyState === &#x27;loading&#x27;) &#123;      document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; sbAlbum.init());    &#125; else &#123;      // DOM已加载，直接初始化      sbAlbum.init();    &#125;  &#125;  // 绑定初始化事件（覆盖DOM加载、主题Pjax等场景）  document.addEventListener(&#x27;DOMContentLoaded&#x27;, initSbAlbum);  document.addEventListener(&#x27;page:loaded&#x27;, initSbAlbum); // 主题页面加载事件  document.addEventListener(&#x27;pjax:complete&#x27;, initSbAlbum); // 主题Pjax完成事件  // 紧急初始化（防止上述事件未触发）  setTimeout(() =&gt; &#123;    if (!sbAlbum.loadState.isAlbumInit) &#123;      console.log(&#x27;执行紧急初始化&#x27;);      initSbAlbum();    &#125;  &#125;, 1000);// 2. 相册核心HTML结构.div.sb-album-container  // 相册头部（筛选栏 + 加载指示器）  .sb-album-header    // 文件夹筛选标签区    .sb-tag-section      .sb-tag-filters.sb-folder-tags        button.sb-tag-filter.sb-active(data-folder=&quot;latest&quot;) 最新        // 文件夹标签将通过JavaScript动态加载    // 加载状态指示器    .sb-loading-indicator      i.fas.fa-spinner.fa-spin      span 正在加载图片和文件夹...  // 图片画廊容器（图片动态加载）  .sb-album-gallery#sbAlbumGallery    // 图片将通过JavaScript动态加载到这里  // 分页控件  .sb-pagination#sbPagination    button.sb-pagination-btn#sbPrevPage(disabled) 上一页    .sb-page-info#sbPageInfo 第 1 页 / 共 1 页    button.sb-pagination-btn#sbNextPage(disabled) 下一页  // 图片预览模态框  .sb-modal.sb-album-modal#sbImageModal    span.sb-close-btn &amp;times;    // 图片导航按钮（上一张/下一张）    button.sb-nav-btn.sb-prev-img-btn(aria-label=&quot;上一张&quot;)      i.fas.fa-chevron-left    button.sb-nav-btn.sb-next-img-btn(aria-label=&quot;下一张&quot;)      i.fas.fa-chevron-right    // 图片缩放控制按钮    .sb-zoom-controls      button.sb-zoom-btn.sb-zoom-in(aria-label=&quot;放大&quot;)        i.fas.fa-search-plus      button.sb-zoom-btn.sb-zoom-out(aria-label=&quot;缩小&quot;)        i.fas.fa-search-minus      button.sb-zoom-btn.sb-zoom-reset(aria-label=&quot;重置缩放&quot;)        i.fas.fa-compress-arrows-alt    // 预览图片容器    .sb-modal-image-container      img.sb-modal-content.sb-album-modal-img#sbModalImage// 3. 相册完整CSS样式（确保与原效果一致）style.  /* 变量定义 - 可根据主题调整 */  :root &#123;    --btn-bg: #e2e8f0;    --btn-color: #4a5568;    --btn-hover-color: #38b2ac;  &#125;  /* 相册容器样式 - 强制隔离，避免与主题样式冲突 */  .sb-album-container &#123;    max-width: 1400px;    margin: 0 auto;    padding: 2rem 1rem;    overflow: visible !important;    isolation: isolate; /* 关键：样式完全隔离 */    min-height: 0; /* 不影响父容器高度计算 */    box-sizing: border-box; /* 确保padding不溢出 */    position: relative; /* 建立独立的z-index上下文 */    z-index: 1; /* 低于页脚z-index */  &#125;  /* 图片加载淡入动画 */  @keyframes sbFadeIn &#123;    from &#123;      opacity: 0;      transform: translateY(10px);    &#125;    to &#123;      opacity: 1;      transform: translateY(0);    &#125;  &#125;  /* 相册头部样式 */  .sb-album-container .sb-album-header &#123;    text-align: center;    margin-bottom: 2rem;  &#125;  .sb-album-container .sb-album-header h2 &#123;    font-size: 2.5rem;    margin-bottom: 0.5rem;    color: #333;  &#125;  .sb-album-container .sb-album-header p &#123;    color: #666;    margin-bottom: 1.5rem;  &#125;  /* 文件夹筛选标签样式 */  .sb-album-container .sb-tag-section &#123;    margin-bottom: 1.5rem;    padding: 0.5rem;    border-radius: 8px;    background-color: transparent;  &#125;  .sb-album-container .sb-tag-filters &#123;    display: flex;    flex-wrap: wrap;    gap: 0.5rem;    padding: 0.5rem;    justify-content: center;  &#125;  .sb-album-container .sb-tag-filter &#123;    padding: 0.4rem 1rem;    border: none;    border-radius: 20px;    background-color: var(--btn-bg);    color: var(--btn-color);    text-align: center;;    font-size: 0.9rem;    cursor: pointer;    transition: all 0.3s ease;  &#125;  .sb-album-container .sb-tag-filter:hover &#123;    background-color: var(--btn-hover-color);  &#125;  .sb-album-container .sb-tag-filter.sb-active &#123;    background-color: var(--btn-hover-color);    color: white;  &#125;  /* 加载指示器样式 */  .sb-album-container .sb-loading-indicator &#123;    display: flex;    align-items: center;    justify-content: center;    gap: 0.5rem;    color: #666;    padding: 2rem;  &#125;  /* 瀑布流核心布局 */  .sb-album-container .sb-album-gallery &#123;    display: block;    column-width: 250px; /* 基础列宽 */    column-gap: 1.5rem; /* 列之间的间距 */    margin-bottom: 2rem;    orphans: 1; /* 防止单个卡片被分割到下一列顶部 */    widows: 1; /* 防止单个卡片被分割到上一列底部 */  &#125;  /* 瀑布流卡片样式 */  .sb-album-container .sb-album-item &#123;    border-radius: 8px;    overflow: hidden;    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);    transition: transform 0.3s ease, box-shadow 0.3s ease;    cursor: pointer;    position: relative;    break-inside: avoid; /* 关键：禁止卡片被列分割 */    margin-bottom: 1.5rem; /* 卡片底部间距 */    display: inline-block;    width: 100%; /* 确保卡片占满列宽 */  &#125;  /* 图片项加载/加载完成状态 */  .sb-album-container .sb-album-item-loading &#123;    opacity: 0;    visibility: hidden;  &#125;  .sb-album-container .sb-album-item-loaded &#123;    opacity: 1;    visibility: visible;  &#125;  .sb-album-container .sb-album-item:hover &#123;    transform: translateY(-5px);    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);  &#125;  /* 图片容器：自适应高度 */  .sb-album-container .sb-image-wrapper &#123;    width: 100%;    position: relative;    overflow: hidden;  &#125;  /* 图片样式：自适应高度，保持比例 */  .sb-album-container .sb-album-img &#123;    width: 100%;    height: auto; /* 高度随图片比例自适应 */    object-fit: cover;    transition: transform 0.5s ease;    filter: none !important; /* 防止主题滤镜影响 */    display: block; /* 清除图片下方空白间隙 */  &#125;  /* 图片加载/加载完成动画 */  .sb-album-container .sb-album-img-loading &#123;    opacity: 0;  &#125;  .sb-album-container .sb-album-img-loaded &#123;    animation: sbFadeIn 0.5s ease forwards;  &#125;  .sb-album-container .sb-album-item:hover .sb-image-wrapper .sb-album-img &#123;    transform: scale(1.05);  &#125;  /* 图片hover遮罩层 */  .sb-album-container .sb-image-overlay &#123;    position: absolute;    bottom: 0;    left: 0;    right: 0;    background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));    padding: 0.8rem;    color: white;    transform: translateY(100%);    transition: transform 0.3s ease;    display: flex;    justify-content: center;    align-items: center;  &#125;  .sb-album-container .sb-album-item:hover .sb-image-overlay &#123;    transform: translateY(0);  &#125;  /* 图片信息标签样式 */  .sb-album-container .sb-image-info &#123;    display: flex;    flex-wrap: wrap;    gap: 0.5rem;    justify-content: center;  &#125;  .sb-album-container .sb-folder-tag &#123;    font-size: 0.8rem;    padding: 0.2rem 0.7rem;    border-radius: 4px;    background-color: rgba(56, 178, 172, 0.7);  &#125;  .sb-album-container .sb-date-tag &#123;    font-size: 0.8rem;    padding: 0.2rem 0.7rem;    border-radius: 4px;    background-color: rgba(100, 116, 139, 0.7);  &#125;  /* 网格加载状态样式 */  .sb-album-container .sb-grid-loading &#123;    display: flex;    align-items: center;    justify-content: center;    gap: 0.5rem;    color: #666;    padding: 4rem 2rem;    width: 100%; /* 跨所有列 */    break-inside: avoid;    margin-bottom: 1.5rem;  &#125;  /* 无图片提示样式 */  .sb-album-container .sb-no-images &#123;    width: 100%; /* 跨所有列 */    text-align: center;    padding: 4rem 2rem;    color: #999;    break-inside: avoid;    margin-bottom: 1.5rem;  &#125;  .sb-album-container .sb-no-images i &#123;    font-size: 3rem;    margin-bottom: 1rem;    display: block;  &#125;  /* 分页控件样式 */  .sb-album-container .sb-pagination &#123;    display: none; /* 默认隐藏，有图片时分页显示 */    justify-content: center;    align-items: center;    gap: 1rem;    margin: 2rem 0;  &#125;  .sb-album-container .sb-pagination-btn &#123;    padding: 0.5rem 1rem;    border: none;    border-radius: 4px;    background-color: #38b2ac;    color: white;    cursor: pointer;    transition: background-color 0.3s ease;  &#125;  .sb-album-container .sb-pagination-btn:disabled &#123;    background-color: #a0aec0;    cursor: not-allowed;    opacity: 0.7;  &#125;  .sb-album-container .sb-pagination-btn:hover:not(:disabled) &#123;    background-color: #319795;  &#125;  .sb-album-container .sb-page-info &#123;    color: #666;    font-size: 0.9rem;  &#125;  /* 预览模态框基础样式 */  .sb-album-container .sb-album-modal &#123;    display: none;    position: fixed;    z-index: 1000;    left: 0;    top: 0;    width: 100%;    height: 100%;    background-color: rgba(0, 0, 0, 0.9);  &#125;  /* 预览图片容器 */  .sb-album-container .sb-modal-image-container &#123;    width: 100%;    height: 100%;    display: flex;    align-items: center;    justify-content: center;    cursor: zoom-out;    padding: 1rem;    box-sizing: border-box;    overflow: auto; /* 缩放后可滚动查看完整图片 */  &#125;  /* 预览图片样式 */  .sb-album-container .sb-album-modal-img &#123;    max-width: 95%;    max-height: 95%;    object-fit: contain;    transition: transform 0.1s ease; /* 平滑缩放过渡 */    transform-origin: center center; /* 从中心缩放 */  &#125;  /* 预览图片加载/加载完成动画 */  .sb-album-container .sb-modal-img-loading &#123;    opacity: 0;  &#125;  .sb-album-container .sb-modal-img-loaded &#123;    animation: sbFadeIn 0.3s ease forwards;  &#125;  /* 关闭按钮样式 */  .sb-album-container .sb-close-btn &#123;    position: absolute;    top: 1.5rem;    right: 2.5rem;    color: white;    font-size: 2.5rem;    font-weight: bold;    transition: 0.3s;    cursor: pointer;    z-index: 1001;  &#125;  .sb-album-container .sb-close-btn:hover &#123;    color: #bbb;    transform: scale(1.1);  &#125;  /* 预览页导航按钮样式 */  .sb-album-container .sb-nav-btn &#123;    position: absolute;    top: 50%;    transform: translateY(-50%);    background-color: rgba(0, 0, 0, 0.5);    color: white;    border: none;    width: 60px;    height: 60px;    border-radius: 50%;    font-size: 1.5rem;    cursor: pointer;    display: flex;    align-items: center;    justify-content: center;    transition: all 0.3s ease;    z-index: 1001;    opacity: 0.7;  &#125;  .sb-album-container .sb-nav-btn:hover &#123;    background-color: rgba(0, 0, 0, 0.8);    opacity: 1;    transform: translateY(-50%) scale(1.1);  &#125;  .sb-album-container .sb-prev-img-btn &#123;    left: 1rem;  &#125;  .sb-album-container .sb-next-img-btn &#123;    right: 1rem;  &#125;  /* 导航按钮禁用状态 */  .sb-album-container .sb-nav-btn.sb-disabled &#123;    opacity: 0.3;    cursor: not-allowed;  &#125;  .sb-album-container .sb-nav-btn.sb-disabled:hover &#123;    background-color: rgba(0, 0, 0, 0.5);    transform: translateY(-50%);  &#125;  /* 缩放控制按钮样式 */  .sb-album-container .sb-zoom-controls &#123;    position: absolute;    bottom: 2rem;    left: 50%;    transform: translateX(-50%);    display: flex;    gap: 0.5rem;    z-index: 1001;  &#125;  .sb-album-container .sb-zoom-btn &#123;    background-color: rgba(0, 0, 0, 0.5);    color: white;    border: none;    width: 40px;    height: 40px;    border-radius: 50%;    cursor: pointer;    display: flex;    align-items: center;    justify-content: center;    transition: all 0.3s ease;    opacity: 0.7;  &#125;  .sb-album-container .sb-zoom-btn:hover &#123;    background-color: rgba(0, 0, 0, 0.8);    opacity: 1;    transform: scale(1.1);  &#125;  /* 响应式适配（移动端） */  @media (max-width: 768px) &#123;    .sb-album-container .sb-album-gallery &#123;      column-width: 150px;      column-gap: 1rem;    &#125;        .sb-album-container .sb-album-item &#123;      margin-bottom: 1rem;    &#125;    .sb-album-container .sb-close-btn &#123;      top: 1rem;      right: 1.5rem;      font-size: 2rem;    &#125;    .sb-album-container .sb-tag-filter &#123;      padding: 0.3rem 0.8rem;      font-size: 0.8rem;    &#125;    .sb-album-container .sb-pagination &#123;      gap: 0.5rem;    &#125;    .sb-album-container .sb-pagination-btn &#123;      padding: 0.4rem 0.8rem;      font-size: 0.9rem;    &#125;    /* 移动端缩小导航按钮 */    .sb-album-container .sb-nav-btn &#123;      width: 40px;      height: 40px;      font-size: 1rem;    &#125;    /* 移动端缩小缩放按钮 */    .sb-album-container .sb-zoom-btn &#123;      width: 36px;      height: 36px;    &#125;  &#125;  /* 平板端适配 */  @media (min-width: 769px) and (max-width: 1024px) &#123;    .sb-album-container .sb-album-gallery &#123;      column-width: 200px;    &#125;  &#125;  /* 模态框打开时禁止页面滚动 */  body.sb-modal-open &#123;    overflow: hidden !important;  &#125;// 4. 相册完整JavaScript逻辑（关联主题配置中的私密信息）script.  // 直接在这里定义配置（替换为你的实际信息）  const SB_ALBUM_CONFIG = &#123;    COS_SCRIPT_URL: &quot;https://cdn.jsdmirror.com/npm/cos-js-sdk-v5@1.4.5/dist/cos-js-sdk-v5.min.js&quot;,    RETRY: &#123;      MAX_COUNT: 10,      INTERVAL: 1000,      INIT_TIMEOUT: 20000    &#125;,    // 直接硬编码配置（替换为你的实际值）    IMAGES_PER_PAGE: #&#123;theme.album.page.images_per_page&#125;,    ZOOM: &#123;      MIN: 0.1,      MAX: 5,      STEP: 0.1,      DEFAULT: 1    &#125;,    ANIMATION: &#123;      FADE_IN_DELAY: 80,      FADE_IN_DURATION: 500    &#125;  &#125;;  const sbAlbum = &#123;    // 关键：从主题配置获取COS私密信息（避免硬编码）    cosConfig: &#123;      Bucket: &#x27;#&#123;theme.album.cos.bucket&#125;&#x27;,       // COS Bucket（主题配置）      Region: &#x27;#&#123;theme.album.cos.region&#125;&#x27;,       // COS地域（主题配置）      RootFolder: &#x27;#&#123;theme.album.cos.root_folder&#125;&#x27;, // COS根文件夹（主题配置）      CdnDomain: &#x27;#&#123;theme.album.cos.cdn_domain&#125;&#x27;, // CDN域名（主题配置）      SecretId: &#x27;#&#123;theme.album.cos.secret_id&#125;&#x27;,   // 私密SecretId（主题配置）      SecretKey: &#x27;#&#123;theme.album.cos.secret_key&#125;&#x27;  // 私密SecretKey（主题配置）    &#125;,    // 加载状态管理    loadState: &#123;      isCosLoaded: false,      isAlbumInit: false,      isLoading: false,      retryCount: 0,      initTimeout: null    &#125;,    // 核心数据存储    cos: null,    allImages: [],         // 所有图片（按时间排序）    filteredImages: [],    // 当前筛选后的图片    allFolders: new Set(), // 所有文件夹    currentFolder: &#x27;latest&#x27;, // 当前选中文件夹（默认&quot;最新&quot;）    currentPage: 1,        // 当前页码    totalPages: 1,         // 总页数    loadedImageKeys: new Set(), // 已加载的图片Key（避免重复）    // 预览相关状态    currentPreviewIndex: -1,    // 当前预览图片的索引    currentZoomLevel: SB_ALBUM_CONFIG.ZOOM.DEFAULT, // 当前缩放级别    // DOM元素缓存    elements: &#123;&#125;,    // 初始化入口    init() &#123;      if (this.loadState.isAlbumInit || this.loadState.isLoading) return;      this.resetState();      // 获取相册容器（确保DOM已加载）      this.elements.container = document.querySelector(&#x27;.sb-album-container&#x27;);      if (!this.elements.container) &#123;        console.warn(&quot;未找到相册容器，100ms后重试&quot;);        setTimeout(() =&gt; this.init(), 100);        return;      &#125;      // 缓存所有需要操作的DOM元素      this.elements.gallery = this.elements.container.querySelector(&#x27;#sbAlbumGallery&#x27;);      this.elements.loadingIndicator = this.elements.container.querySelector(&#x27;.sb-loading-indicator&#x27;);      this.elements.folderTagFilters = this.elements.container.querySelector(&#x27;.sb-folder-tags&#x27;);      this.elements.modal = this.elements.container.querySelector(&#x27;#sbImageModal&#x27;);      this.elements.modalImage = this.elements.container.querySelector(&#x27;#sbModalImage&#x27;);      this.elements.modalImageContainer = this.elements.container.querySelector(&#x27;.sb-modal-image-container&#x27;);      this.elements.closeBtn = this.elements.container.querySelector(&#x27;.sb-close-btn&#x27;);      this.elements.pagination = this.elements.container.querySelector(&#x27;#sbPagination&#x27;);      this.elements.prevPageBtn = this.elements.container.querySelector(&#x27;#sbPrevPage&#x27;);      this.elements.nextPageBtn = this.elements.container.querySelector(&#x27;#sbNextPage&#x27;);      this.elements.pageInfo = this.elements.container.querySelector(&#x27;#sbPageInfo&#x27;);      this.elements.prevImgBtn = this.elements.container.querySelector(&#x27;.sb-prev-img-btn&#x27;);      this.elements.nextImgBtn = this.elements.container.querySelector(&#x27;.sb-next-img-btn&#x27;);      this.elements.zoomInBtn = this.elements.container.querySelector(&#x27;.sb-zoom-in&#x27;);      this.elements.zoomOutBtn = this.elements.container.querySelector(&#x27;.sb-zoom-out&#x27;);      this.elements.zoomResetBtn = this.elements.container.querySelector(&#x27;.sb-zoom-reset&#x27;);      // 绑定所有事件      this.bindEvents();      // 启动加载流程      this.startLoadingProcess();      // 标记初始化完成      this.loadState.isAlbumInit = true;    &#125;,    // 启动加载流程（加载COS SDK + 初始化COS）    startLoadingProcess() &#123;      this.loadState.isLoading = true;      this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;正在加载资源...&lt;/span&gt;&#x27;);      // 若COS已加载，直接初始化；否则加载SDK      if (window.COS) &#123;        this.loadState.isCosLoaded = true;        this.initializeCosAndLoadImages();        return;      &#125;      // 加载COS SDK（带重试机制）      this.loadCosSdk()        .then(() =&gt; this.initializeCosAndLoadImages())        .catch(err =&gt; &#123;          console.error(&#x27;COS SDK加载失败:&#x27;, err);          this.retryLoadCosSdk();        &#125;);    &#125;,    // 初始化COS客户端并加载图片/文件夹    initializeCosAndLoadImages() &#123;      try &#123;        // 初始化COS客户端        this.cos = new COS(&#123;          SecretId: this.cosConfig.SecretId,          SecretKey: this.cosConfig.SecretKey        &#125;);        // 更新加载状态        this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;&lt;span&gt;正在加载图片和文件夹...&lt;/span&gt;&#x27;);        // 加载COS中的图片和文件夹        this.getCosImagesAndFolders()          .then(() =&gt; this.loadState.isLoading = false)          .catch(err =&gt; &#123;            console.error(&#x27;加载图片失败:&#x27;, err);            this.loadState.isLoading = false;            this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;&lt;span&gt;加载图片失败，请重试&lt;/span&gt;&#x27;);          &#125;);      &#125; catch (err) &#123;        console.error(&#x27;初始化COS失败:&#x27;, err);        this.loadState.isLoading = false;        this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;&lt;span&gt;初始化失败，请重试&lt;/span&gt;&#x27;);      &#125;    &#125;,    // 加载COS SDK（Promise封装）    loadCosSdk() &#123;      return new Promise((resolve, reject) =&gt; &#123;        // 清除已有超时器        if (this.loadState.initTimeout) clearTimeout(this.loadState.initTimeout);        // 设置加载超时        this.loadState.initTimeout = setTimeout(() =&gt; &#123;          reject(new Error(`COS SDK加载超时`));        &#125;, SB_ALBUM_CONFIG.RETRY.INIT_TIMEOUT);        // 检查SDK是否已加载        let cosScript = document.querySelector(`script[src=&quot;$&#123;SB_ALBUM_CONFIG.COS_SCRIPT_URL&#125;&quot;]`);        if (cosScript) &#123;          // 轮询检查SDK是否就绪          const checkLoaded = () =&gt; &#123;            if (window.COS) &#123;              clearTimeout(this.loadState.initTimeout);              this.loadState.isCosLoaded = true;              resolve();            &#125; else &#123;              setTimeout(checkLoaded, 100);            &#125;          &#125;;          checkLoaded();          return;        &#125;        // 动态创建SDK脚本        cosScript = document.createElement(&quot;script&quot;);        cosScript.src = SB_ALBUM_CONFIG.COS_SCRIPT_URL;        cosScript.type = &quot;text/javascript&quot;;        // 加载成功回调        cosScript.onload = () =&gt; &#123;          clearTimeout(this.loadState.initTimeout);          this.loadState.isCosLoaded = true;          resolve();        &#125;;        // 加载失败回调        cosScript.onerror = (err) =&gt; &#123;          clearTimeout(this.loadState.initTimeout);          reject(new Error(`COS SDK加载失败: $&#123;err.message&#125;`));        &#125;;        // 插入脚本到头部        document.head.appendChild(cosScript);      &#125;);    &#125;,    // 重试加载COS SDK（带次数限制）    retryLoadCosSdk() &#123;      if (this.loadState.retryCount &gt;= SB_ALBUM_CONFIG.RETRY.MAX_COUNT) &#123;        this.loadState.isLoading = false;        this.updateLoadingIndicator(`          &lt;i class=&quot;fas fa-exclamation-triangle text-red-500&quot;&gt;&lt;/i&gt;          &lt;span&gt;无法加载必要组件，请检查网络后刷新页面&lt;/span&gt;        `);        return;      &#125;      // 增加重试次数并更新状态      this.loadState.retryCount++;      this.updateLoadingIndicator(`        &lt;i class=&quot;fas fa-spinner fa-spin&quot;&gt;&lt;/i&gt;        &lt;span&gt;正在重试加载（$&#123;this.loadState.retryCount&#125;/$&#123;SB_ALBUM_CONFIG.RETRY.MAX_COUNT&#125;）...&lt;/span&gt;      `);      // 延迟重试      setTimeout(() =&gt; &#123;        this.loadCosSdk()          .then(() =&gt; this.initializeCosAndLoadImages())          .catch(() =&gt; this.retryLoadCosSdk());      &#125;, SB_ALBUM_CONFIG.RETRY.INTERVAL);    &#125;,    // 从COS获取图片和文件夹列表    async getCosImagesAndFolders() &#123;      try &#123;        // 调用COS API获取文件列表        const listResult = await new Promise((resolve, reject) =&gt; &#123;          this.cos.getBucket(&#123;            Bucket: this.cosConfig.Bucket,            Region: this.cosConfig.Region,            Prefix: this.cosConfig.RootFolder,            MaxKeys: 1000 // 单次最大获取数量（可根据需求调整）          &#125;, (err, data) =&gt; err ? reject(err) : resolve(data));        &#125;);        // 提取图片和文件夹信息        const imageItems = [];        const rootLength = this.cosConfig.RootFolder.length;        // 遍历COS返回的文件列表        listResult.Contents.forEach(item =&gt; &#123;          // 跳过已加载的图片（避免重复）          if (this.loadedImageKeys.has(item.Key)) return;          // 检查是否为图片文件（通过后缀名判断）          const ext = item.Key.split(&#x27;.&#x27;).pop()?.toLowerCase();          const isImage = ext &amp;&amp; [&#x27;jpg&#x27;, &#x27;jpeg&#x27;, &#x27;png&#x27;, &#x27;gif&#x27;, &#x27;webp&#x27;, &#x27;avif&#x27;].includes(ext);          if (isImage) &#123;            // 提取文件夹名称（若有）            const pathWithoutRoot = item.Key.substring(rootLength);            const folderSeparatorIndex = pathWithoutRoot.indexOf(&#x27;/&#x27;);            let folder = &#x27;未分类&#x27;; // 默认文件夹            // 若存在文件夹分隔符，提取文件夹名            if (folderSeparatorIndex &gt; 0) &#123;              folder = pathWithoutRoot.substring(0, folderSeparatorIndex);            &#125;            // 存储图片信息            imageItems.push(&#123;              key: item.Key,              url: `$&#123;this.cosConfig.CdnDomain&#125;/$&#123;item.Key&#125;`, // 图片CDN链接              name: item.Key.split(&#x27;/&#x27;).pop().split(&#x27;.&#x27;).slice(0, -1).join(&#x27;.&#x27;), // 图片名称（不含后缀）              folder: folder, // 所属文件夹              lastModified: new Date(item.LastModified) // 最后修改时间（用于排序）            &#125;);            // 记录文件夹和已加载图片            this.allFolders.add(folder);            this.loadedImageKeys.add(item.Key);          &#125;        &#125;);        // 处理无图片场景        if (imageItems.length === 0) &#123;          this.updateLoadingIndicator(&#x27;&lt;i class=&quot;fas fa-image text-gray-400&quot;&gt;&lt;/i&gt;&lt;span&gt;未找到图片&lt;/span&gt;&#x27;);          this.updatePagination(0); // 隐藏分页          return;        &#125;        // 按修改时间排序（最新在前）        this.allImages = imageItems.sort((a, b) =&gt; b.lastModified - a.lastModified);        // 隐藏加载指示器        if (this.elements.loadingIndicator) &#123;          this.elements.loadingIndicator.style.display = &#x27;none&#x27;;        &#125;        // 渲染文件夹筛选标签、筛选图片、更新分页、显示图片        this.displayFolderTagFilters();        this.filterImages();        this.updatePagination(this.filteredImages.length);        this.displayCurrentPageImages();      &#125; catch (err) &#123;        console.error(&#x27;获取图片列表失败:&#x27;, err);        throw err;      &#125;    &#125;,    // 渲染文件夹筛选标签    displayFolderTagFilters() &#123;      if (!this.elements.folderTagFilters) return;      // 清除现有标签（保留&quot;最新&quot;标签）      Array.from(this.elements.folderTagFilters.children).forEach(child =&gt; &#123;        if (child.dataset.folder !== &#x27;latest&#x27;) child.remove();      &#125;);      // 为每个文件夹创建筛选标签      Array.from(this.allFolders).forEach(folder =&gt; &#123;        const tagBtn = document.createElement(&#x27;button&#x27;);        tagBtn.className = &#x27;sb-tag-filter&#x27;;        tagBtn.dataset.folder = folder;        tagBtn.textContent = folder;        // 绑定筛选事件        tagBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.handleFolderTagClick(folder));        this.elements.folderTagFilters.appendChild(tagBtn);      &#125;);    &#125;,    // 文件夹筛选标签点击事件    handleFolderTagClick(folder) &#123;      this.currentFolder = folder;      this.currentPage = 1; // 切换文件夹时重置到第一页      // 显示加载状态      this.elements.gallery.innerHTML = `        &lt;div class=&quot;sb-grid-loading&quot;&gt;          &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;          &lt;span&gt;正在加载$&#123;folder&#125;分类的图片...&lt;/span&gt;        &lt;/div&gt;      `;      // 更新筛选标签活跃状态      this.elements.container.querySelectorAll(&#x27;.sb-folder-tags .sb-tag-filter&#x27;).forEach(btn =&gt; &#123;        btn.classList.remove(&#x27;sb-active&#x27;);      &#125;);      this.elements.container.querySelector(`.sb-folder-tags .sb-tag-filter[data-folder=&quot;$&#123;folder&#125;&quot;]`)?.classList.add(&#x27;sb-active&#x27;);      // 延迟处理（确保加载状态显示）      setTimeout(() =&gt; &#123;        this.filterImages();        this.updatePagination(this.filteredImages.length);        this.displayCurrentPageImages();      &#125;, 300);    &#125;,    // 筛选当前文件夹的图片    filterImages() &#123;      if (this.currentFolder === &#x27;latest&#x27;) &#123;        // &quot;最新&quot;分类：显示所有图片        this.filteredImages = [...this.allImages];      &#125; else &#123;        // 特定文件夹：筛选对应图片        this.filteredImages = this.allImages.filter(image =&gt; image.folder === this.currentFolder);      &#125;    &#125;,    // 更新分页信息（总页数、按钮状态）    updatePagination(totalItems) &#123;      if (!this.elements.pagination) return;      // 计算总页数      this.totalPages = Math.max(1, Math.ceil(totalItems / SB_ALBUM_CONFIG.IMAGES_PER_PAGE));      // 更新页码文本      this.elements.pageInfo.textContent = `第 $&#123;this.currentPage&#125; 页 / 共 $&#123;this.totalPages&#125; 页`;      // 更新分页按钮禁用状态      this.elements.prevPageBtn.disabled = this.currentPage &lt;= 1;      this.elements.nextPageBtn.disabled = this.currentPage &gt;= this.totalPages;      // 只有一页时隐藏分页      this.elements.pagination.style.display = this.totalPages &lt;= 1 ? &#x27;none&#x27; : &#x27;flex&#x27;;    &#125;,    // 显示当前页的图片（带逐张淡入动画）    displayCurrentPageImages() &#123;      if (!this.elements.gallery) return;      this.elements.gallery.innerHTML = &#x27;&#x27;;      // 计算当前页图片的索引范围      const startIndex = (this.currentPage - 1) * SB_ALBUM_CONFIG.IMAGES_PER_PAGE;      const endIndex = startIndex + SB_ALBUM_CONFIG.IMAGES_PER_PAGE;      const currentPageImages = this.filteredImages.slice(startIndex, endIndex);      // 处理当前页无图片场景      if (currentPageImages.length === 0) &#123;        const message = this.filteredImages.length === 0          ? &#x27;暂无图片&#x27;          : `在&quot;$&#123;this.currentFolder&#125;&quot;中没有更多图片`;        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-no-images&quot;&gt;            &lt;i class=&quot;fas fa-search text-gray-300&quot;&gt;&lt;/i&gt;            &lt;p&gt;$&#123;message&#125;&lt;/p&gt;          &lt;/div&gt;        `;        return;      &#125;      // 批量创建图片元素（用DocumentFragment优化性能）      const fragment = document.createDocumentFragment();      currentPageImages.forEach((image, index) =&gt; &#123;        // 创建图片项容器        const imageCard = document.createElement(&#x27;div&#x27;);        imageCard.className = &#x27;sb-album-item sb-album-item-loading&#x27;; // 初始加载状态        imageCard.dataset.folder = image.folder;        imageCard.dataset.imageKey = image.key;        imageCard.dataset.index = startIndex + index; // 记录在筛选列表中的索引        // 格式化日期显示（YYYY-MM-DD）        const formattedDate = this.formatDate(image.lastModified);        // 图片项HTML结构        imageCard.innerHTML = `          &lt;div class=&quot;sb-image-wrapper&quot;&gt;            &lt;!-- 占位图（避免布局抖动） --&gt;            &lt;img src=&quot;data:image/svg+xml,%3Csvg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; viewBox=&#x27;0 0 200 200&#x27;%3E%3Crect width=&#x27;200&#x27; height=&#x27;200&#x27; fill=&#x27;%23f3f4f6&#x27;/%3E%3C/svg%3E&quot;                 data-src=&quot;$&#123;image.url&#125;&quot;                 alt=&quot;$&#123;image.name&#125;&quot;                 class=&quot;lazyload sb-album-img sb-album-img-loading&quot;&gt;            &lt;!-- 图片hover遮罩 --&gt;            &lt;div class=&quot;sb-image-overlay&quot;&gt;              &lt;div class=&quot;sb-image-info&quot;&gt;                &lt;span class=&quot;sb-folder-tag&quot;&gt;$&#123;image.folder&#125;&lt;/span&gt;                &lt;span class=&quot;sb-date-tag&quot;&gt;$&#123;formattedDate&#125;&lt;/span&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;        `;        // 绑定预览事件        imageCard.addEventListener(&#x27;click&#x27;, () =&gt; &#123;          const imageIndex = parseInt(imageCard.dataset.index);          this.openImageModal(image.url, imageIndex);        &#125;);        fragment.appendChild(imageCard);      &#125;);      // 批量插入图片项      this.elements.gallery.appendChild(fragment);      // 初始化懒加载      this.initThemeLazyLoad();      // 逐张显示图片（添加淡入动画）      const imageItems = this.elements.gallery.querySelectorAll(&#x27;.sb-album-item&#x27;);      imageItems.forEach((item, index) =&gt; &#123;        setTimeout(() =&gt; &#123;          // 移除加载状态，添加加载完成状态          item.classList.remove(&#x27;sb-album-item-loading&#x27;);          item.classList.add(&#x27;sb-album-item-loaded&#x27;);          // 图片加载完成后添加淡入动画          const img = item.querySelector(&#x27;.sb-album-img&#x27;);          if (img.complete) &#123;            img.classList.remove(&#x27;sb-album-img-loading&#x27;);            img.classList.add(&#x27;sb-album-img-loaded&#x27;);          &#125; else &#123;            img.addEventListener(&#x27;load&#x27;, () =&gt; &#123;              img.classList.remove(&#x27;sb-album-img-loading&#x27;);              img.classList.add(&#x27;sb-album-img-loaded&#x27;);            &#125;);          &#125;        &#125;, index * SB_ALBUM_CONFIG.ANIMATION.FADE_IN_DELAY);      &#125;);      // 滚动到相册顶部（提升体验）      window.scrollTo(&#123; top: this.elements.container.offsetTop - 20, behavior: &#x27;smooth&#x27; &#125;);    &#125;,    // 上一页    prevPage() &#123;      if (this.currentPage &gt; 1) &#123;        // 显示加载状态        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-grid-loading&quot;&gt;            &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;            &lt;span&gt;正在加载上一页图片...&lt;/span&gt;          &lt;/div&gt;        `;        // 更新页码        this.currentPage--;        // 更新分页信息        this.updatePagination(this.filteredImages.length);        // 延迟加载（确保加载状态显示）        setTimeout(() =&gt; &#123;          this.displayCurrentPageImages();        &#125;, 300);      &#125;    &#125;,    // 下一页    nextPage() &#123;      if (this.currentPage &lt; this.totalPages) &#123;        // 显示加载状态        this.elements.gallery.innerHTML = `          &lt;div class=&quot;sb-grid-loading&quot;&gt;            &lt;i class=&quot;fas fa-spinner fa-spin text-gray-400&quot;&gt;&lt;/i&gt;            &lt;span&gt;正在加载下一页图片...&lt;/span&gt;          &lt;/div&gt;        `;        // 更新页码        this.currentPage++;        // 更新分页信息        this.updatePagination(this.filteredImages.length);        // 延迟加载（确保加载状态显示）        setTimeout(() =&gt; &#123;          this.displayCurrentPageImages();        &#125;, 300);      &#125;    &#125;,    // 格式化日期（YYYY-MM-DD）    formatDate(date) &#123;      const year = date.getFullYear();      const month = String(date.getMonth() + 1).padStart(2, &#x27;0&#x27;);      const day = String(date.getDate()).padStart(2, &#x27;0&#x27;);      return `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;`;    &#125;,    // 初始化懒加载（兼容主题自带懒加载）    initThemeLazyLoad() &#123;      if (window.LazyLoad) &#123;        // 若主题已加载LazyLoad，用主题的懒加载        new LazyLoad(&#123;          elements_selector: &#x27;.sb-album-container img.lazyload&#x27;,          threshold: 300        &#125;);      &#125; else if (window.lazyLoadInstance) &#123;        // 若主题有懒加载实例，更新实例        window.lazyLoadInstance.update();      &#125; else &#123;        //  fallback：直接加载图片        setTimeout(() =&gt; &#123;          document.querySelectorAll(&#x27;.sb-album-container img.lazyload&#x27;).forEach(img =&gt; &#123;            if (img.dataset.src &amp;&amp; img.src !== img.dataset.src) &#123;              img.src = img.dataset.src;              img.classList.remove(&#x27;lazyload&#x27;);            &#125;          &#125;);        &#125;, 500);      &#125;    &#125;,    // 打开图片预览模态框    openImageModal(url, index) &#123;      if (!this.elements.modal || !this.elements.modalImage) return;      // 记录当前预览图片的索引      this.currentPreviewIndex = index;      // 重置缩放级别      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();      // 先设置透明占位图（避免布局抖动）      this.elements.modalImage.src = &#x27;data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;1&quot; height=&quot;1&quot;%3E%3Crect width=&quot;1&quot; height=&quot;1&quot; fill=&quot;transparent&quot;/%3E%3C/svg%3E&#x27;;      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 显示模态框      this.elements.modal.style.display = &#x27;block&#x27;;      // 禁止页面滚动      document.body.classList.add(&#x27;sb-modal-open&#x27;);      // 预加载图片（提升体验）      const img = new Image();      img.onload = () =&gt; &#123;        this.elements.modalImage.src = url;        // 图片加载完成后添加淡入动画        setTimeout(() =&gt; &#123;          this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);          this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);        &#125;, 50);      &#125;;      img.src = url;      // 更新预览导航按钮状态      this.updateNavButtonsState();    &#125;,    // 关闭图片预览模态框    closeImageModal() &#123;      if (!this.elements.modal) return;      // 隐藏模态框      this.elements.modal.style.display = &#x27;none&#x27;;      // 恢复页面滚动      document.body.classList.remove(&#x27;sb-modal-open&#x27;);      // 重置缩放和动画状态      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);    &#125;,    // 预览页：上一张图片    prevImage() &#123;      if (this.currentPreviewIndex &lt;= 0) return;      // 隐藏当前图片（过渡效果）      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 延迟加载下一张（确保过渡效果可见）      setTimeout(() =&gt; &#123;        // 更新预览索引        this.currentPreviewIndex--;        const prevImage = this.filteredImages[this.currentPreviewIndex];        // 预加载上一张图片        const img = new Image();        img.onload = () =&gt; &#123;          this.elements.modalImage.src = prevImage.url;          // 图片加载完成后显示          setTimeout(() =&gt; &#123;            this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);            this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);          &#125;, 50);        &#125;;        img.src = prevImage.url;        // 重置缩放        this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;        this.updateImageZoom();        // 更新导航按钮状态        this.updateNavButtonsState();      &#125;, 200);    &#125;,    // 预览页：下一张图片    nextImage() &#123;      if (this.currentPreviewIndex &gt;= this.filteredImages.length - 1) return;      // 隐藏当前图片（过渡效果）      this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loaded&#x27;);      this.elements.modalImage.classList.add(&#x27;sb-modal-img-loading&#x27;);      // 延迟加载下一张（确保过渡效果可见）      setTimeout(() =&gt; &#123;        // 更新预览索引        this.currentPreviewIndex++;        const nextImage = this.filteredImages[this.currentPreviewIndex];        // 预加载下一张图片        const img = new Image();        img.onload = () =&gt; &#123;          this.elements.modalImage.src = nextImage.url;          // 图片加载完成后显示          setTimeout(() =&gt; &#123;            this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);            this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);          &#125;, 50);        &#125;;        img.src = nextImage.url;        // 重置缩放        this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;        this.updateImageZoom();        // 更新导航按钮状态        this.updateNavButtonsState();      &#125;, 200);    &#125;,    // 更新预览页导航按钮状态（禁用/启用）    updateNavButtonsState() &#123;      // 第一页：禁用上一张      this.elements.prevImgBtn.disabled = this.currentPreviewIndex &lt;= 0;      // 最后一页：禁用下一张      this.elements.nextImgBtn.disabled = this.currentPreviewIndex &gt;= this.filteredImages.length - 1;      // 添加禁用视觉样式      if (this.currentPreviewIndex &lt;= 0) &#123;        this.elements.prevImgBtn.classList.add(&#x27;sb-disabled&#x27;);      &#125; else &#123;        this.elements.prevImgBtn.classList.remove(&#x27;sb-disabled&#x27;);      &#125;      if (this.currentPreviewIndex &gt;= this.filteredImages.length - 1) &#123;        this.elements.nextImgBtn.classList.add(&#x27;sb-disabled&#x27;);      &#125; else &#123;        this.elements.nextImgBtn.classList.remove(&#x27;sb-disabled&#x27;);      &#125;    &#125;,    // 图片放大    zoomIn() &#123;      if (this.currentZoomLevel &lt; SB_ALBUM_CONFIG.ZOOM.MAX) &#123;        this.currentZoomLevel += SB_ALBUM_CONFIG.ZOOM.STEP;        this.updateImageZoom();      &#125;    &#125;,    // 图片缩小    zoomOut() &#123;      if (this.currentZoomLevel &gt; SB_ALBUM_CONFIG.ZOOM.MIN) &#123;        this.currentZoomLevel -= SB_ALBUM_CONFIG.ZOOM.STEP;        this.updateImageZoom();      &#125;    &#125;,    // 重置图片缩放    resetZoom() &#123;      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.updateImageZoom();    &#125;,    // 应用图片缩放（更新DOM样式）    updateImageZoom() &#123;      if (this.elements.modalImage) &#123;        this.elements.modalImage.style.transform = `scale($&#123;this.currentZoomLevel&#125;)`;      &#125;    &#125;,    // 绑定所有交互事件    bindEvents() &#123;      // 分页按钮事件      if (this.elements.prevPageBtn) &#123;        this.elements.prevPageBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.prevPage());      &#125;      if (this.elements.nextPageBtn) &#123;        this.elements.nextPageBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.nextPage());      &#125;      // 预览页导航按钮事件      if (this.elements.prevImgBtn) &#123;        this.elements.prevImgBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation(); // 阻止事件冒泡          this.prevImage();        &#125;);      &#125;      if (this.elements.nextImgBtn) &#123;        this.elements.nextImgBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.nextImage();        &#125;);      &#125;      // 缩放控制按钮事件      if (this.elements.zoomInBtn) &#123;        this.elements.zoomInBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.zoomIn();        &#125;);      &#125;      if (this.elements.zoomOutBtn) &#123;        this.elements.zoomOutBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.zoomOut();        &#125;);      &#125;      if (this.elements.zoomResetBtn) &#123;        this.elements.zoomResetBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.resetZoom();        &#125;);      &#125;      // 预览图片容器点击事件（关闭模态框）      if (this.elements.modalImageContainer) &#123;        this.elements.modalImageContainer.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          e.preventDefault();          this.closeImageModal();        &#125;);      &#125;      // 模态框点击事件（点击背景关闭）      if (this.elements.modal) &#123;        this.elements.modal.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          if (e.target === this.elements.modal) &#123;            this.closeImageModal();          &#125;        &#125;);        // 滚轮缩放事件        this.elements.modal.addEventListener(&#x27;wheel&#x27;, (e) =&gt; &#123;          e.preventDefault();          e.stopPropagation();          // 滚轮向上：放大；向下：缩小          if (e.deltaY &lt; 0) &#123;            this.zoomIn();          &#125; else &#123;            this.zoomOut();          &#125;        &#125;, &#123; passive: false &#125;);        // 键盘导航事件        this.elements.modal.addEventListener(&#x27;keydown&#x27;, (e) =&gt; &#123;          switch (e.key) &#123;            case &#x27;ArrowLeft&#x27;: // 左箭头：上一张              e.preventDefault();              this.prevImage();              break;            case &#x27;ArrowRight&#x27;: // 右箭头：下一张              e.preventDefault();              this.nextImage();              break;            case &#x27;Escape&#x27;: // ESC：关闭模态框              e.preventDefault();              this.closeImageModal();              break;            case &#x27;+&#x27;: // 加号：放大            case &#x27;=&#x27;:              e.preventDefault();              this.zoomIn();              break;            case &#x27;-&#x27;: // 减号：缩小              e.preventDefault();              this.zoomOut();              break;            case &#x27;0&#x27;: // 0：重置缩放              e.preventDefault();              this.resetZoom();              break;          &#125;        &#125;);      &#125;      // 关闭按钮事件      if (this.elements.closeBtn) &#123;        this.elements.closeBtn.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;          e.stopPropagation();          this.closeImageModal();        &#125;);      &#125;      // 预览图片加载失败处理      if (this.elements.modalImage) &#123;        this.elements.modalImage.addEventListener(&#x27;error&#x27;, (e) =&gt; &#123;          e.stopPropagation();          // 加载失败时显示占位图          this.elements.modalImage.src = &#x27;data:image/svg+xml,%3Csvg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 300 200&quot;%3E%3Crect width=&quot;300&quot; height=&quot;200&quot; fill=&quot;%23333&quot;/%3E%3Ctext x=&quot;50%&quot; y=&quot;50%&quot; dominant-baseline=&quot;middle&quot; text-anchor=&quot;middle&quot; fill=&quot;%23fff&quot;%3E图片无法加载%3C/text%3E%3C/svg%3E&#x27;;          this.elements.modalImage.classList.remove(&#x27;sb-modal-img-loading&#x27;);          this.elements.modalImage.classList.add(&#x27;sb-modal-img-loaded&#x27;);        &#125;);      &#125;      // &quot;最新&quot;标签点击事件      if (this.elements.folderTagFilters) &#123;        const latestBtn = this.elements.folderTagFilters.querySelector(&#x27;.sb-tag-filter[data-folder=&quot;latest&quot;]&#x27;);        if (latestBtn) &#123;          latestBtn.addEventListener(&#x27;click&#x27;, () =&gt; this.handleFolderTagClick(&#x27;latest&#x27;));        &#125;      &#125;    &#125;,    // 重置相册状态（用于重新初始化）    resetState() &#123;      this.allImages = [];      this.filteredImages = [];      this.allFolders.clear();      this.currentFolder = &#x27;latest&#x27;;      this.currentPage = 1;      this.totalPages = 1;      this.currentPreviewIndex = -1;      this.currentZoomLevel = SB_ALBUM_CONFIG.ZOOM.DEFAULT;      this.loadedImageKeys.clear();      this.elements = &#123;&#125;;      this.cos = null;      // 重置加载状态      this.loadState = &#123;        isCosLoaded: window.COS ? true : false,        isAlbumInit: false,        isLoading: false,        retryCount: 0,        initTimeout: null      &#125;;      // 恢复页面滚动      document.body.classList.remove(&#x27;sb-modal-open&#x27;);    &#125;,    // 更新加载指示器文本    updateLoadingIndicator(html) &#123;      const loadingEl = this.elements.loadingIndicator || document.querySelector(&#x27;.sb-album-container .sb-loading-indicator&#x27;);      if (loadingEl) &#123;        loadingEl.innerHTML = html;        loadingEl.style.display = &#x27;flex&#x27;;      &#125;    &#125;,    // 销毁相册（释放资源）    destroy() &#123;      this.resetState();      if (this.elements.modal) &#123;        this.elements.modal.style.display = &#x27;none&#x27;;      &#125;    &#125;  &#125;;  // 相册初始化函数（兼容DOM加载和主题Pjax）  function initSbAlbum() &#123;    sbAlbum.destroy(); // 先销毁旧实例，避免重复    // 若DOM未加载完成，等待DOM加载    if (document.readyState === &#x27;loading&#x27;) &#123;      document.addEventListener(&#x27;DOMContentLoaded&#x27;, () =&gt; sbAlbum.init());    &#125; else &#123;      // DOM已加载，直接初始化      sbAlbum.init();    &#125;  &#125;  // 绑定初始化事件（覆盖DOM加载、主题Pjax等场景）  document.addEventListener(&#x27;DOMContentLoaded&#x27;, initSbAlbum);  document.addEventListener(&#x27;page:loaded&#x27;, initSbAlbum); // 主题页面加载事件  document.addEventListener(&#x27;pjax:complete&#x27;, initSbAlbum); // 主题Pjax完成事件  // 紧急初始化（防止上述事件未触发）  setTimeout(() =&gt; &#123;    if (!sbAlbum.loadState.isAlbumInit) &#123;      console.log(&#x27;执行紧急初始化&#x27;);      initSbAlbum();    &#125;  &#125;, 1000);\n\n然后在主题配置文件中添加以下配置，密钥建议新建一个子用户，然后只给获取文件列表权限：\n\nalbum:  cos:    bucket: &#x27; &#x27;       # 你的COS Bucket名    region: &#x27; &#x27;               # 你的COS地域    root_folder: &#x27;album/&#x27;                    # 照片文件夹（根文件夹留空）    cdn_domain: &#x27;https://xxx&#x27; # 你的CDN域名    secret_id: &#x27;xxx&#x27;  # 私密SecretId    secret_key: &#x27;xxx&#x27;     # 私密SecretKey  # 非私密配置（可选：也可放这里统一管理）  page:    images_per_page: 20                # 每页显示图片数\n\n在对象存储root_folder中，新建自己需要分类的照片文件，将照片上传到对应的文件夹中即可：\n\n\n\n最后就可以在相册页面看到效果啦，如果配合腾讯云自己的CosBrowser和数据万象的话，就可以实现随时上传并压缩转换格式啦：\n\n\n\n最后叨叨\n个人水平有限，本文仅仅是自己的一个想法实现的过程记录，如果有大佬看见的话可以帮忙优化一下哈哈。\n","categories":["主题魔改（抄袭）记录"],"tags":["butterfly","腾讯云","相册","对象存储"]},{"title":"腾讯云cos跨域问题记录","url":"/posts/b883ec18/","content":"写前哔哔\n最近想为我的Twikoo添加新的表情包，根据教程需要建立一个json文件放在自己的云存储中，但是当json文件上传到腾讯云cos时，添加链接到Twikoo后点击表情按钮没有反应，而同样的文件添加到多吉云存储时却是正常的。依旧通过豆包大法得知，腾讯云 COS 默认未配置跨域访问规则，导致 Twikoo 无法加载 JSON 文件。多吉云可能已默认开放跨域请求，因此正常工作。\n正片开始\n\n\n登录腾讯云 COS 控制台\n进入目标存储桶的 安全管理 &gt; 跨域访问 (CORS) 页面。\n\n\n添加 CORS 规则\n\n\n来源 (Origin)：填写 Twikoo 所在的域名（如https://yourdomain.com），支持泛域名（如https://*.yourdomain.com）。\n\n\n操作 (Methods)：勾选 GET（Twikoo 仅需读取 JSON 文件）。\n\n\n允许头部 (Allow-Headers)：填写*（允许所有请求头）。\n\n\n暴露头部 (Expose-Headers)：建议填写Etag。\n\n\n超时 (Max-Age)：设置为600（单位：秒）。\n\n\n返回 Vary: Origin：勾选该选项以兼容不同来源的请求。\n\n\n\n\n\nTips：如果存储桶还绑定了CDN加速域名，比如EdgeOne，还要刷新一下缓存才能起效，如果仍然没有效果，需要根据腾讯云教程添加http响应头，EdgeOne默认透传，不需额外添加。\n\n\n补充：跨域访问 vs 防盗链 核心区别\n最开始我以为是由于防盗链原因，所以搜了两者之间的区别：\n\n\n\n对比项\n跨域访问\n防盗链\n\n\n\n\n目的\n保护用户数据安全（防止跨站脚本窃取数据）\n保护服务器资源（防止被其他网站盗用，节省带宽）\n\n\n限制方\n由浏览器主动限制（前端限制）\n由服务器主动限制（后端限制）\n\n\n针对的请求\n主要限制 “脚本发起的跨域数据请求”（如 AJAX、Fetch）\n主要限制 “资源文件的引用”（如图片、视频、音频、文件）\n\n\n允许的方式\n服务器通过设置 Access-Control-Allow-Origin 响应头，允许指定域名跨域请求\n服务器通过设置白名单（允许的 Referer），允许指定域名引用资源\n\n\n典型例子\na.com 的 JS 无法直接请求 b.com 的接口数据（除非 b.com 开了 CORS）\nb.com 盗用 a.com 的图片，a.com 服务器拒绝返回图片\n\n\n\n\n跨域访问：浏览器怕 “数据被偷”，不让不同网站的脚本随便通信；\n防盗链：服务器怕 “资源被蹭”，不让其他网站随便用自己的图片 / 视频。\n\n最后叨叨\n个人纯小白，全程豆包编码，仅做个人成功案例分享，大佬勿喷。\n","categories":["一些乱七八糟"],"tags":["腾讯云","cors","跨域"]},{"title":"我们所需要的婚礼","url":"/posts/9ad23602/","content":"前言\n就在今年五月份我办完了自己人生中的婚礼，国庆期间也参加了几场朋友的婚礼，发现这其中的很多事情确实有诸多不合理，心中憋了很久想说的，今天就来简单吐槽一下。\n正文\n谁是主角\n就现在而言，“父母之命，媒妁之言”这种情况已经基本不会出现了，我们可以自由地寻找自己所爱的另一半，但是到了婚礼这一关，会发现其实父母的在婚礼中的参与度比我们想象的还要高。\n从最开始的彩礼开始，我们就早已没了主动权，即使提出自己的意见，起到的作用却微乎其微。虽然大可以直接绕过父母直接领证，然后各过各的，但这样无疑就是相当于让女方跟家中断绝关系，因此不到迫不得已，这种做法并不可取。\n说回婚礼本身，首先是办不办的问题，其实很多人包括我自己一直想着不办婚礼，直接出门旅行，或者最多办一个简单的仪式，只请一些亲朋好友吃顿酒席即可。但这种做法目前只有极少数人可以实现，对于大多数人来说，订婚、出阁、婚礼、回门等仪式应该是只多不少，原因就是父母需要。这其中那男女方父母都有自己的心思，对于男方父母来说，他们担心婚礼办的不体面会丢自己面子，对于女方父母而言，婚礼置办的不风光就是瞧不起自家的女儿。再往细了谈，比如说邀请对象，父母通常会邀请自己交际圈的人来参加我们的婚礼，可这些人我们几乎没有认识的，反而是我最想要感谢的朋友，却因为酒席人数太多，没有和他们尽情地分享自己的喜悦；再比如一些时间点，就拿我自己来说，我当时定了一个假期比较靠中间的婚礼日期，以此来方便我的一些外省的朋友来参加，但父母非要根据我和女方的生辰八字确定日期，最后将我的计划搞得一团糟。\n以上种种，不禁让我发出疑问，究竟谁才是婚礼的主角，从头到尾，就好似是父母是操盘人，而我们只是供人观赏的对象而已。\n婚礼的开支\n婚礼的开支可谓是结婚的一大门槛，尤其是对于刚参加工作不久的新人来说，如果不依赖父母的资助几乎不能完成这场浩大的仪式（这也间接导致了以上所讨论的婚礼主角问题），而这其中必然包含了我认为的两种开支。\n首先说说不公平开支，因为一些传统的观念，男方承担了绝大部分的婚礼开支，包括但不限于彩礼、三金或者五金、酒席、婚庆等，当然因为地域和家庭差异，这其中有些项目是由男女双方共同承担的，而我重点说的是彩礼与金饰这一问题。在我看来，这两种简直是我不能理解的存在，彩礼要是直接给女方也还好，但如果遇到一些“人贩子”父母，他们会将彩礼全部据为己有，然后还会美其名曰替女儿进行保管。三金五金更不必说，买了之后就是“传家宝”般的存在，就是订婚的时候用一下而已。\n然后是不必要开支，这部分跟家庭条件有着密切关系，但是对于绝大部分的普通家庭而言，因为攀比心理，秉承着别人有我也得有这样的想法，他们往往选择了与自身经济条件并不匹配的消费水平。与此同时，婚庆行业也是“趁火打劫”，广告铺天盖地，诱导着我们购入了原本不需要的消费项目。但其实只要自身稍微能保持一点理性，我觉得一些开支完全是可以节省下来的。比如说我自己的婚礼上，四大金刚我就只找了主持人与跟拍，因为取消了接亲游戏，所以我并没有找伴郎伴娘团（另外提一句，到底谁规定伴郎伴娘团只能找未婚男女，有些人因为身边没有适龄的亲戚朋友，还要专门花钱请，这我是完全不能理解的）；再拿我朋友举例子，她将出阁宴与订婚宴放在一起解决，省去了两家来回跑的烦恼。\n因此，在我看来，除非家财万贯，想把婚礼办成一场盛大的演出，否则我觉得有些开支完全没有必要支出，至于不公平开支，估计只能交给我们这一代人当父母的时候解决了。\n结语\n好希望一切都能重来。。。\n看点别的\n刷抖音时刷到一些有趣的婚礼图片，大家自行找亮点哈哈：\n\n    [{\"url\":\"https://image.sunboy.ltd/20251007165741205.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007165825281.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007165901447.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007165920680.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007165948966.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007170013513.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007170031187.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007170049307.avif\",\"alt\":\"\",\"title\":\"\"},{\"url\":\"https://image.sunboy.ltd/20251007170105562.avif\",\"alt\":\"\",\"title\":\"\"}]\n  ","categories":["狂人日记"],"tags":["婚礼"]},{"title":"Hexo博客实现腾讯云EdgeOne自动化刷新","url":"/posts/308ecd71/","content":"写前哔哔\n最近也是上了腾讯云EdgeOne的免费末班车，但是对于我这种懒人来说，每次都要手动刷新缓存简直是太难了，尤其是腾讯云老是要求要扫码更要老命了。后来无意中看到了 青桔气球的文章，实现了不用登陆腾讯云就能刷新缓存，但这个方法还是要手动node EdgeOne.js才行，那对我这种懒人必须得优化优化，于是豆包大法开始（为什么用豆包，因为我毫无相关基础，只是代码的搬运工。。。）。\n正片开始\n\n首先在博客根目录下新建一个scripts文件夹，然后在该文件夹内新建一个edgeone-cache.js文件。\n安装必要依赖（我也不知道装哪个，反正我都装了）：\n\nnpm install tencentcloud-sdk-nodejsnpm install tencentcloud-sdk-nodejs-teo\n\n复制粘贴以下代码：\n\nconst tencentcloud = require(&quot;tencentcloud-sdk-nodejs-teo&quot;);const TeoClient = tencentcloud.teo.v20220901.Client;// 从 Hexo 配置读取 EdgeOne 参数const edgeoneCfg = hexo.config.edgeone || &#123;&#125;;// 若未启用，直接退出if (!edgeoneCfg.enable) &#123;  console.log(&quot;[EdgeOne] 缓存刷新已禁用（edgeone.enable=false）&quot;);  return;&#125;// 初始化腾讯云 TEO 客户端const client = new TeoClient(&#123;  credential: &#123;    secretId: edgeoneCfg.secretId,    secretKey: edgeoneCfg.secretKey,  &#125;,  region: edgeoneCfg.region || &quot;ap-guangzhou&quot;,  profile: &#123; httpProfile: &#123; endpoint: &quot;teo.tencentcloudapi.com&quot; &#125; &#125;,&#125;);/** * 执行 EdgeOne 缓存刷新 */async function refreshCache() &#123;  try &#123;    const params = &#123;      ZoneId: edgeoneCfg.zoneId, // 必传：EdgeOne 站点 ID      Type: edgeoneCfg.type || &quot;purge_host&quot;, // 刷新类型      Targets: edgeoneCfg.targets || [hexo.config.url], // 刷新目标      Method: edgeoneCfg.method || &quot;invalidate&quot;, // 清除方式    &#125;;    const res = await client.CreatePurgeTask(params);    // 空值保护：校验响应结构    if (res &amp;&amp; res.Response) &#123;      if (res.Response.TaskId) &#123;        console.log(`✅ EdgeOne 刷新成功 | 任务 ID：$&#123;res.Response.TaskId&#125;`);        console.log(`→ 类型：$&#123;params.Type&#125; | 方式：$&#123;params.Method&#125;`);        console.log(`→ 目标：$&#123;JSON.stringify(params.Targets)&#125;`);      &#125; else &#123;        console.error(`⚠️ API 响应无 TaskId：`, res.Response);      &#125;    &#125; else &#123;      console.error(`⚠️ API 响应异常：`, res);    &#125;  &#125; catch (err) &#123;    console.error(`❌ EdgeOne 刷新失败：$&#123;err.code&#125; | $&#123;err.message&#125;`);    hexo.log.error(err); // 记录错误，不中断部署  &#125;&#125;// 绑定 Hexo 部署完成钩子hexo.on(&quot;deployAfter&quot;, async () =&gt; &#123;  console.log(&quot;\\n=== EdgeOne 缓存自动刷新启动 ===&quot;);  await refreshCache();  console.log(&quot;=== EdgeOne 缓存刷新结束 ===\\n&quot;);&#125;);\n根据豆包描述，这个脚本利用了 Hexo 的deployAfter钩子，确保在部署完成后才执行缓存刷新操作，保证了内容已经更新到服务器后再刷新缓存，避免了无效的缓存刷新。\n\n然后在_config.yaml里边添加以下配置文件：\n\nedgeone:  enable: true               # 是否启用（必填，true/false）  secretId: &quot;***&quot;  # 访问密钥 ID（必填）  secretKey: &quot;***&quot; # 访问密钥 Key（必填）  zoneId: &quot;***&quot;      # EdgeOne 站点 ID（必填，格式如 zone-xxx）  type: &quot;***&quot;         # 刷新类型：purge_host/purge_url/purge_prefix/purge_all  targets:                   # 刷新目标（数组，根据 type 填写）    - &quot;***&quot;    - &quot;***&quot;     method: &quot;***&quot;       # 清除方式：invalidate/delete\n关键参数解释：\nsecretId和secretKey在腾讯云访问密钥 - 控制台创建，一组密钥secretKey只在创建的时候出现一次，注意保存。\nzoneId在腾讯云EO服务总览-&gt;站点概览。\n\ntype与targets对应关系，可同时配置多个targets：\n\n\n\n需求\n配置值\n示例 Targets\n\n\n\n\n全站缓存\npurge_all\n无需填写 Targets\n\n\n域名级缓存\npurge_host\n&quot;blog.qjqq.cn&quot;\n\n\n目录级缓存（如 /blog）\npurge_prefix\n&quot;https://blog.qjqq.cn/blog/&quot;\n\n\n单页面缓存\npurge_url\n&quot;https://blog.qjqq.cn/posts/123.html&quot;\n\n\n\ninvalidate（标记过期）：将缓存标记为 “过期”，后续用户请求时，CDN 会回源校验资源是否真的过期（不会立即删除缓存，而是懒校验）。\ndelete（直接删除）：直接从 CDN 节点的缓存中物理删除资源，后续请求会直接回源获取最新内容。\n\n执行hexo d，出现EdgeOne刷新结束后，打开个人博客验证是否刷新成功（出现API响应异常不影响刷新）。\n\n\n最后叨叨\n个人纯小白，全程豆包编码，仅做个人成功案例分享，大佬勿喷。\n参考教程\nHexo使用EdgeOne接口实现自动化刷新缓存https://blog.qjqq.cn/posts/3f45.html\n","categories":["一些乱七八糟"],"tags":["hexo","腾讯云","EdgeOne"]},{"title":"问答分享：有个妹妹是种什么体验","url":"/posts/fb28/","content":"现在感觉短视频占据了我很大部分的时间，导致我没有静下心来去吃一些“慢餐”，所有今后会单独开一个分类去分享一些文章或者回答又或者是书籍，这对我来说也是一种自我约束的方法，当然也有水文的嫌疑哈哈，那么今天就从一些简单的回答分享开始吧。\n前言\n因为我是家中最小的，属于是小皇帝那种，所以从来不知道弟、妹是怎样一种生物，知乎也很很懂我啊，跳出了这个话题，那就让我好好看一下别人家拥有妹妹是一种什么感觉。\nP1 可爱捏\n作者：匿名用户\n链接：https://www.zhihu.com/question/293914303/answer/495932361\n来源：知乎\n\n 点击展开全文 \n              \n              大二，跟妹妹年龄差18带她出门应该算比较有趣的体验了因为身高差好多（答主184）所以比起牵着更像在手上提着233手很小只，握手腕会不小心弄疼她，除了过马路有时是她攥住我的食指有次雪天出门比较着急，她全程不配合我，然后费了好大的劲才把她塞进羽绒服里，路上特怨念的瞄我……然后有了下图哈哈哈上课听着mede:mede 忽然好想妹妹啊别别别叫我大舅子了在成都上学，所以没法补日常更一张从我姐朋友圈偷来的图（之前表述有问题 被误认成184的女生）新更一朵体验（10.21）妹妹临睡前忽然要求跟我通话我猜可能是她不想睡觉吧，强行拖时间虽然我依然不懂如何和小孩子谈笑风生她呢，一本正经的讲述幼儿园的奇妙经历撸完铁后举手机很累，便催她早点睡觉觉emmm她特甜的说了一句*“哥哥 晚安 爱你 做个好梦”*我愣住“嗯？哦……好的……爱你”一路上疯狂回想假期陪她看过的150多集Peppa里的对话谁教她的。。。\n              \n            \n这个简直太可爱了，萌萌哒！\n\nP2 小天使\n作者：里灰\n链接：https://mp.weixin.qq.com/s/WVqoGnplm6phudFggRb8dg\n来源：微信公众号\n\n 点击展开全文 \n              \n              我可能是全网唯一一个写妹妹出了书的人吧~就是那本《你是这世界写给我的情书》（统一回复：某宝可买的~）妹妹九岁了，叫芊卉，我二十三，图中是她四五岁时的照片，怕别人把她偷走，所以不发近照~1有次芊卉妹妹自己过马路买东西。等红灯时，她走神了，绿灯亮了她还在发呆。一阿姨走了几步好心回头提醒她：“可以走了，小妹妹。”她回过神来，一看绿灯就跑，突然一辆闯红灯的车从她脸前飞驰而过……她回来跟我说这事，吓得我一身汗。我把她搂在怀里问：“你当时怕不怕？”她：“哥哥，你猜我当时头脑里第一个反应是什么？”我：“脑袋空白？”她摇头。我：“眼前一黑？”她摇头。我：“浑身僵硬，感觉无法控制自己，想尿裤子？”她摇头。我：“那是啥？”她：“我想的是，幸好没撞到我，如果我被撞了，那提醒我‘可以走了’的那个阿姨肯定会很难过。”2我妈托云南亲戚给我寄了二十几包中药，说能治抑郁症。我妈一天给我熬三遍药，熬的家里全是中药味。没几天我就崩溃了，在家里连呼吸都是苦的，最可怕的是，那个味道时时刻刻在提醒我，我是个病人。遇上邻居，邻居还会问吃这么多药是怎么了？我说抑郁症人家听不懂，我总不能说精神病吧，就只好说感冒。有的邻居不信，略带怀疑的问我：“你是不是在调理身体备孕啊？”药喝完了，没用，但又不忍心跟我妈说实话，但如果骗她说有用，那我还得接着喝，苦不说，关键是贵，好几千块，像是被人骗了。我妈每次听说哪哪有神医，谁谁得了白血病几副中药就喝好了，眼睛就发光。她不是一个迷信的人，她只是太需要希望了。某中午，我到客厅找吃的，看见我妹在厨房，踩着好几本书，站在灶台前，用湿抹布小心翼翼地提起药壶盖子，从大红袋子里拿什么东西往我药里放。她做贼似的，我怕吓着她，就没出声，假装什么都没看见。我回房忙完工作，才又走到厨房去看看，找了半天才找到那个大红袋子，里面是冰糖。芊卉给我放的，是冰糖。她怕我苦。我一直觉得我这种类型的抑郁症无药可医，中药西药我都没觉得有什么效果，但当我想起那个明亮的中午厨房里妹妹站在书本上偷偷往我药里放冰糖，我就觉得温暖。药不苦，时间苦。冰糖不甜，你甜。3我妹舞蹈考级，我们约定好的，我骑车带她去。但我完全忘了，前一晚跟姨弟康在外面通宵浪了一夜，早上回来睡得不省人事。我妈最恨我熬夜，暴怒，就逼我妹把我叫起来，打车带她去考级。我妹无论如何不愿意叫醒我，要哭似地求我妈说：“就你带我去嘛，让哥哥睡觉，就你带我去嘛，让哥哥睡觉，就你带我去嘛，让哥哥睡觉…”我妈最后说：“好，就算是我带你去，你也得把她叫起来，治治他。”我妹说：“不要。”然后气得坐在沙发上生气。我妈：“你不叫，我也不带你去。”我妹气得眼泪直掉，撇嘴说：“不去就不去，我就不叫，你不心疼他我还心疼呢。”4每天忙完工作室的事，就是下午了，太阳将落，开始有风，我就骑着小白羊（电车）带着她穿梭在大街小巷，去找好吃的。上个月底我看支付宝账单，光给她买吃的，就花了4300多块。真想不起钱都是怎么花的了，感觉不该那么多。但一品品这段时间的幸福感，就觉得也差不多，因为每次看她吃好吃的东西吃得手舞足蹈，我就感觉很幸福，既然我这段时间那么幸福，那肯定就没少买买买咯，也就想通了。我：“芊卉姐姐，你太能吃了，养不起你了。”她：“哼，养不起你也得养！”5如果你问我哪一刻最痛苦，我会说是从熟睡中苏醒的那一刻。我不愿接受自己还活着。有次我妹问我：“哥哥，为什么每次你睡醒了都不开心？”我：“因为我不喜欢这个世界，我更喜欢梦里那个世界。”她没再说话，没听懂的样子。第二天上午，我如往常一样，痛苦地缓缓地睁开眼，看见我妹的小脸蛋正冲我笑。我：“你怎么睡我这了？”她笑着说：“我来接你来到这个世界。”6每次我妹让我给她扎头发，我只要一怠慢，我爸就在旁边说：“你好好珍惜吧，等以后嫁人了，你想帮还轮不到了呢……”有次我在手机上下象棋，她来找我扎头发，我低着头说：你自己扎一下，我正在激战,马上赢了，你长大了哈，自己扎一下，乖~我大战三百回，终于赢了，一抬头看见她披头散发地站在门口，我大惊：“你站门口干嘛？”她气哼哼地说：“我要去嫁人了！！！”我：“好好好，求你别嫁，求你别嫁！我帮你扎，我帮你扎……”所以在这里友情提示未来妹夫，请务必学会扎头发，不然你老婆可能会气到改嫁！！！7我小时候，特别害怕死亡。有次夜里，奶奶搂着我睡觉的时候，跟我说：“人死了就会去阴曹地府找阎王爷报道，坏人会被打下十八层地狱，永世不得超生，好人喝了孟婆汤，就能转世成人了…….有些人不听话，不喝孟婆汤，阎王爷就会打他屁股，所以有些小孩生下来屁股就是青的……”奶奶的话给了我巨大的安慰，因为我皮肤不算黑，黄黄的，唯独屁股黑，所以一定是阎王爷打的，这就是证实了奶奶的话，所以人死了一定是可以转世成人的！嗨呀，我整个人都明亮起来了，再没因担心自己会死而难过了。有次我趴在我妹床头给她读睡前故事，一个关于死亡的故事，她缩在被窝里，问我：“哥哥，人可以不死吗？”我愣了，不知怎么回答。她眼神有些恐惧，追问：“人一定会死吗？”我呼了口气，沉重地说：“是啊。”她皱着眉头担心地问：“那死了怎么办呢？”我又愣住了，不知怎么答。她追问：“就没有这个身体了是不是？就不能吃了，就不能玩了，就看不见你和爸爸妈妈了，是不是？”我：“是。”我看得出她很恐惧。她又问我：“那怎么办呢？”我：“人死了，灵魂就会出窍，然后去阴曹地府报到，排好队，阎王爷会安排再出生一次，上辈子我俩就是一起排的队，我记得，你就在我前面呢，然后我俩被安排进了同一个生命隧道里，才成了兄妹。”她：“哥哥，那，等以后，你先死，还是我先死？”我：“我比你大14岁呢，我先死。”她没再说话，难过和恐惧都在她脸上。我用拇指蹭了蹭她的脸颊，她一动不动。我：“好啦，你才九岁，一生才刚刚开始呢，你还可以活一百年呢。”她侧过身去，背对着我。过了许久，等她睡了，我才起身，放好书，给她掖好被子。我拉开门要走时，她突然轻声叫我：“哥哥。”我：“嗯？还没睡着？”她哽咽着说：“等你死了，一定要等我。”8我嘴里常生溃疡，我妹听我妈说橘子白筋可以清火，每次家里买来橘子她就全剥了，精心挑出一小碗橘子白筋给我，说：“哥哥，吃橘子筋。”我每次吃完都说：“神奇，好多了，不疼了！”有次她问我：“那你的抑郁症会好吗？”我妈在旁边脱口说：“怎么可能好，都多少年了。”我妹转脸看了我妈一眼，又看我，撇着嘴要哭。我：“会好的。”她：“那你什么时候好？”我：“等你长大我就好了。”她没再说话。然后就吃晚饭了，她一直低头扒米饭不说话，暴饮暴食，胃口很好的样子。我抓住她筷子说：“你吃慢点，吃那么快干嘛？”她抬头嘴一撇，眼泪哗哗洒：“我想明天就长大。”9我妹终于到了七岁八岁狗都嫌的年纪。我忙着毕业那阵，很少给我打电话的老爸，专门给我打了电话，专门吐槽了我妹，说：“你小妹越来越讨厌了，张嘴闭嘴就是抬杠，烦。”我全程哈哈哈笑。我爸：“等你回来就知道了，气死个人。”后来我回家时。发现我妹确实挺爱抬杠的，无逻辑地杠，为了杠而杠，有时候还把握不住边界，难怪我爸会生气。有次我爸被气得脸红，恶狠狠地冲我发火：“你看她跟谁学的！越来越讨厌，你说他讨不讨厌？”讨厌这个词，用我爸那种语气说出来，太重了。这是她第一次被家人讨厌。她站在旁边小脸通红，难过到不知所措。我走向她说：“讨厌，真讨厌！”然后蹲下来抱着她在她红红的脸蛋上使劲嘬了一口说，“可我还是很喜欢怎么办啊！！！”我妹就紧紧搂着我脖子趴在我肩上，一动不动。我就把她抱出去逛商场了，买了很多好吃的。我不知道我怎么知道的，但我就是知道，如果你永远觉得一个小孩可爱，她就会永远可爱。因为我们都有一种本能，就是为喜欢自己的人，而成为更好的人。\n              \n            \n天使般的妹妹就是治愈良药。\n\nP3 中登爆金币\n作者：蓝藻\n链接：https://www.zhihu.com/question/293914303/answer/3313501176\n来源：知乎\n\n 点击展开全文 \n              \n              我有两个妹妹，就……找我的频率是一个月一次，开销大了可能会找第二次。我妹不看知乎，所以我敢发。哈哈哈哈！更新一下吧……四月 小的那个找我爆1500……\n              \n            \n哥哥就是用来爆金币的，这没毛病吧！\n\nP4 相爱相杀\n作者：烈水无轩\n链接：https://www.zhihu.com/question/293914303/answer/3108274937\n来源：知乎\n\n 点击展开全文 \n              \n              在18岁生日的时候送了她特别的成人礼物一开始拿到包超级无敌开心，笑容满面打开以后。。。。令人难忘的成人礼呢，第二年就要高考，真羡慕她有这么体贴的哥哥\n              \n            \n啊这，很难绷啊，不过偶尔捉弄一下也还不错。。。\n\nP5 小粘糕\n作者：安安安\n链接：https://www.zhihu.com/question/293914303/answer/806883353\n来源：知乎\n\n 点击展开全文 \n              \n              有个妹妹，答主姐姐。相差三岁。好多回答都是哥哥，那我站在女生视角来分享一下。*1.get一个小跟屁虫。*从小到大，我去哪儿她就要去哪儿。就连考大学选志愿，第一个想的都是来我在的城市。粘人得很~这个粘是字面意义的“粘”。小时候我们经常一起在家门口玩儿，有时玩儿的嗨了就会跑出去一大截路，等到回家的时候，她人小小的，脸圆圆的，冬天又穿的多，整个人像一只小企鹅跟着我。走两步就会撒娇“姐姐背我”。而我像一个敷衍的男朋友，故意跑出去一小段，然后对她说“你走七步，然后我背你。”就看着她一颠一颠地跑过来，站在马路牙子上让我背。所以直到她都念大学了还念叨着“小时候你都背我，现在都不背了。”我：？？？一百多斤了心里有点数。*2.get一个战友。*场景一：饭后看电视活动。我爸妈“给你们生个弟弟玩儿呀？”我和我妹对视一眼“不可能！”场景二：年夜饭活动我爸“来来来多吃点才能长肉，来吃肉吃肉。”【说着把一大块骨头夹给妹妹】已经吃饱的我妹“姐姐！”我“给我，我吃诶嘿嘿！”场景三：家庭聚餐我爸“早点结婚生个外孙呀！”【催我】我：“？？？”我妹“我姐啥时候结婚是她自己的事，你不要操心啦。”*3.get宫斗技能。*小学的时候家里给我俩买了双层的床。下面那层有蚊帐（小时候觉得美爆了），私心好想睡下面那层，但又怕妹妹也想要我抢不过她，于是就开始了套路我妹的过程。我“哎呀上下铺都很好呀，可我更喜欢上铺，你看上铺多高，从来没睡过这么高的床。”我妹“是呀姐姐，可是下铺像电视剧里公主的床。”我“恩恩，那你喜欢哪个？虽然上铺更舒服但是如果你喜欢上铺的话姐姐也可以让给你。”我妹“姐姐你太好了，那我要上铺。”【在此我要向我妹道歉，我错了，我就是不想爬床想要下铺。】*4.get热爱分享的性格。*从小爸妈买了什么零食玩具，就会自动的一分为二。我记得有一次妈妈给了我们一人两块糖，我先吃了一块，心想另一块留到晚上吃。结果妹妹先把自己的两块吃完了，看着她嘤嘤嘤的眼神，我还能怎么样，还不是乖乖把糖交出去？长大以后，和朋友吃饭自然会注意自己别吃太多给别人留一些，有了好东西也想着和自己在意的人分享一下，简单讲就是——爱送礼（打钱）？*5.get母爱的时间提前了好多年。*小时候爸妈吵架，我带着妹妹“离家出走”在小区待着，我们特别认真商量。“爸妈离婚了你跟谁”的问题。我妹：“爸妈会不会离婚？”我:“有可能，那你跟谁？”我妹：“我想跟着你！”我：“没事，就算爸妈都不要我们了，姐姐不读书去打工也要让你好好的！”那一刻，才十四岁的我，就有了“母爱”的感觉。但还没来得及陶醉在自己的幻想里，我妹沉默一会儿之后说出一句——“不，姐姐你学习好，我去打工！”暴风哭泣真的暴风哭泣！！！我现在还记得那天我们俩义正言辞又大义凛然的样子。但还好，最后我们被爸妈找回去了。*6.get一个贴心小棉袄。*小时候吵闹、争执都有过，但我们俩从来没冷战超过一小时。但大多数情况下我都自持有理而毫不退让（宛若一个冷酷的家长），一番争执过后，她总会泪眼婆娑的来找我，然后说“我错了”。其实哪儿能每次都是她的错，只是她更舍不得我生气，所以先来哄我。【此时觉得自己像一个渣男】长大以后，她越来越敏感细心，总能比我这个早早离家的人更能体会爸妈的辛苦和不易。原来她和妈妈有了争执要我来调和，现在我和妈妈沟通出现问题她反倒成了那个来回安慰劝和的人。这个小棉袄，好像随着年龄增长，保暖值都越来越高了。最近的一次，我刚生了一场病，她虽与我远隔千里，但从得知我生病开始就一直联络我哄我开心，还要来陪着我，竟像是什么都不顾了。那一刻，我感受到了在她心里我是炒鸡炒鸡重要的存在，开心~*7.get一个闺蜜。*真的你信我，妹妹养大了就是你的绝佳闺蜜。随着年龄的增长，姐妹之间的阅历不像读书时那么大鸿沟，她的闺蜜属性就会渐渐盖过她的“晚辈”属性。并且时不时还会扮演一些“姐姐”的戏份。比如最近我在公司加班开会没有吃饭时，她：给我定了奶茶 送到公司比如我跟她讲我夏天没有衣服穿（女人的没有衣服穿你懂得）时，她：她去商场买了好几件寄过来当然，随着年龄越来越大，我也再不是她心里的白月光了。从“我姐牛逼”、“我姐好看”、“我姐完美”逐渐变成了：“我姐好像是个沙雕？”这种变化令我一时头秃。【奉上我过年时的朋友圈，以下内容她全部截图转发到了自己朋友圈以嘲讽我】体重都一样的我俩*8.get一个独特无法割舍的羁绊。*我们俩是有心灵感应的我一直觉得。我前几天做梦，梦到她跟我说要去参军。第二天醒来，我把这个梦分享给她，结果她说，对啊我是报名了，还没告诉你们而已。我大学的时候她有一天给我打电话让我小心点不要出门感觉很慌很危险，我本来要去逛街的，就临时决定不去了。后来我听说在我本来要经过的路上出了一起车祸。这种神秘的心灵感应让我们之间的关系更加的独特，血亲之上更多了一层羁绊。*世界上有那么多感情，唯独这份最独一无二。*我和妹妹之间，小时候打打闹闹嘻嘻哈哈小矛盾不断、后来我总搬出长姐的架势和她相处、现在我们之间越来越平等、更像朋友。有一天我和她倾诉生活的不易，她摸了摸我的背，说“抱抱你。”那一刻，我有种感觉——*吾家有女终长成。*\n              \n            \n就算是粘人精谁又会讨厌呢。\n\nP6 精辟\n作者：草原猎鹰\n链接：https://www.zhihu.com/question/293914303/answer/1905281272244335646\n来源：知乎\n\n 点击展开全文 \n              \n              3岁：抱抱。6岁：哥，你快过来！9岁：回家捎三块钱馒头。12岁：滚！16岁：家人们，谁懂啊……\n              \n            \n这也太真实了，是不同年龄阶段的真实写照吧哈哈，不过对于哥哥或者姐姐来说这也太扎心了！\n\nP7 妹妹的表白\n作者：姑娘没有趣\n链接：https://www.zhihu.com/question/293914303/answer/743428982\n来源：知乎\n\n 点击展开全文 \n              \n              没有亲妹妹，有个亲哥哥。替我哥答一下。顺便表白一下子。我哥今年37。我26。我俩差11岁。小时候，喜欢抱我。没事捏我脸。梳头给我梳三七分。 那时候最喜欢我吧。邻居家有个和他一般大的哥哥，特别想把我跟他弟换换。我哥不同意。再大点，非常嫌弃我跟着他出去玩。嫌我是拖油瓶。还和我争电视。他争不过我。我会哭啊。我一哭，他就不争了。哈哈后来，发现我的价值。让（骗）我给他洗衣服，给他跑腿买东西。说好的宠妹妹呢。从小就和我炫耀自己学习有多好。家里奖状贴了一墙。炫耀自己的字写的好。事实也是这样。不过他没我学习好。哈哈。我爹生病去世。家里负债累累。他无奈辍学。17岁就出去打工。所以那段时间对他的记忆几乎没有。他相过很多次亲。那个时候家庭条件很差。穷又单亲，还有个小妹妹。他不抢手。曾经有一个定亲对象，因为女孩嫌弃我小又上学，我哥想也没想的就和人家掰了。那个时候我就是个拖油瓶。后来和我现在的嫂子结婚，慢慢辛苦的撑起这个家。长兄如父。说得就是他吧。上大学，给我交学费，给我生活费，给我买手机电脑，把他觉得最好的东西都给我。大二手机被我摔坏，没告诉他，想凑合着用用。他知道了给我买了苹果手机。偷偷寄到学校。收到快递我才知道。总给我打钱。问我钱够不够花。回家就给我做好吃的。他应该是世界上最好的哥哥。他总说，养个闺女，就是为了老了有人给他打酒喝。我不是他闺女，他也不爱喝酒。可我以后一定会给他打酒。像闺女一样疼他。他还说，以后不要嫁那么远，走太远，以后你就不和我亲了。他其实有点舍不得我。也离不开我。这个时候他特别像我妈。粘人精。他喝了酒会和我聊我爹。趁我妈不在的时候。因为怕我妈伤心。我对我爹的了解都来自于我哥。他特别想我爹。有时候聊着聊着会哭。如果我爹在，他肯定不会这么辛苦。我们的日子也不会这么辛苦。那个时候他特别像个孩子。他特别粗心。我也是。这一点我们都随我妈。他年轻的时候，特别流行大阳摩托。他买了一辆125。不明白为什么，他会想教给我骑摩托。那么大的摩托车，我推都推不动。教了我两次，就让我骑。后来也骑的很⑥。唉。我本来就大大咧咧的性格。硬是让他带的越来越像个汉子。他在家有时候会让我陪他喝酒。一边让我喝，一边给我上课。说外面都是坏人。只能在家喝酒，外面绝对不行。还有不要相信外面男人的鬼话。听10分信3分。他从不担心我找不到对象，因为他觉得他老妹漂亮贤惠懂事又大方。前段时间，他右腹部疼痛，怀疑阑尾炎。去医院挂急诊，没有查出来什么症状。医生给了两个方案，一是开腹探查，二是回家打消炎针，疼得厉害了再开刀。把我都吓哭了。一点都不想他生病。特别害怕。大概，这就是他带给我和我家人的安全感吧。他在，他健康，我们就都会很安心。上次回家，发现他有白头发了。他以前引以为傲的乌黑秀发。也零星的长出了几根白发。时间真是让人后知后觉的东西。不知不觉，你就奔四了。我也奔三了。小时候抢电视的画面仿佛还在眼前。他很顾家。也会做饭。工作不累的时候会露一手。我和我嫂子就会可劲拍马屁，毕竟他做得是真好吃。他很少抽烟，没烟瘾，偶尔喝酒，但不贪杯。他也有很多缺点。好面子。对别人好过对自己家人。不会教育孩子。有些落伍。很少向家人表达爱。脾气又很倔。谁的意见都听不进去。有时候又很啰嗦。其实，他最大的缺点是太拼，不爱惜自己的身体。但这并不妨碍我们爱他。他喜欢养狗。但我妈和我嫂子都不喜欢。他一个人倔强的买了两条狗，都让我嫂子在他不在家的时候送人了。家庭地位感人。他年轻的时候，练过武术。所以肌肉很发达。以前经常给我炫耀他的胸肌腹肌肱二头肌。现在啤酒肚也有了。他在家院子里买了一套沙袋，歇着的时候会练上两脚。有时候也会教给家里小朋友一些实用招式。看起来很厉害的样子。实际上也很厉害。他喜欢钓鱼。因为技艺不精，从不野钓。上个星期，去鱼塘钓鱼，一条都没钓上来。我嘲笑了他好几天。他经常念叨早起去跑步，念叨3回也就跑一回。后来他每次说，我和我嫂子都不太理他。他不常向家人表达爱。大多数是以批评的口吻，表达对他人的关心。即使我已经向他提了好几次意见。但他就是这样嘴硬心软。这一点也随我妈。我也是。即使刻意的改，有时候也会不自觉的这样表现出来。他大多数都笑皮脸（这是个褒义词，我实在找不到一个合适的词了），一点都不威严。在生活中不是严父。尤其是对他小情人，那叫一个宠和腻歪。他很少给我讲大道理。也从不把我当小孩子。家里很多事会找我商量，让我发表意见。我自己的事情会让我自己决定。自己的事情自己去做，自己去考虑。这么多年，我也算独立吧。他前天给我打电话说，不管做什么，心态最重要。心态放平，好好努力就好。剩下的交给时间。人生的道路不止一条。知足常乐。难得他正经一回，我都有点不习惯。我很爱他。很敬他。也很依赖他。我希望他不要这么辛苦。不要这么拼命。多多的爱自己一些。我希望下辈子我们都能在爸妈的羽翼下长大，他累了，也能有个肩膀让他靠靠，不再一个人硬撑。而我还能做她的小妹妹，拖油瓶，拥有父母，哥姐更多倍的爱。所以，有个亲哥哥到底是什么样的感觉？大概就是幸福幸福和幸福吧。除了爸爸，第二个不求回报，默默爱你的男人。你的港湾和后盾。陪你最久最久的人。久过父母，久过爱人。感谢他。即使没有我爹。我仍然拥有爱，幸福和健全的人格。\n              \n            \n他的哥哥对他而言不是父亲，却给了她胜似一般家庭的爱。\n","categories":["一些分享"],"tags":["分享","知乎","妹妹"]}]